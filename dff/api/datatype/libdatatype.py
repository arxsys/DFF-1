# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libdatatype', [dirname(__file__)])
        except ImportError:
            import _libdatatype
            return _libdatatype
        if fp is not None:
            try:
                _mod = imp.load_module('_libdatatype', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libdatatype = swig_import_helper()
    del swig_import_helper
else:
    import _libdatatype
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libdatatype.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _libdatatype.SwigPyIterator_value(self)
    def incr(self, n=1): return _libdatatype.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _libdatatype.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _libdatatype.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _libdatatype.SwigPyIterator_equal(self, *args)
    def copy(self): return _libdatatype.SwigPyIterator_copy(self)
    def next(self): return _libdatatype.SwigPyIterator_next(self)
    def __next__(self): return _libdatatype.SwigPyIterator___next__(self)
    def previous(self): return _libdatatype.SwigPyIterator_previous(self)
    def advance(self, *args): return _libdatatype.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _libdatatype.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _libdatatype.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _libdatatype.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _libdatatype.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _libdatatype.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _libdatatype.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _libdatatype.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import dff.api.events.libevents
import dff.api.exceptions.libexceptions
class DataTypeHandler(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataTypeHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataTypeHandler, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(DFF::DataTypeHandler self) -> DataTypeHandler

        1
        """
        if self.__class__ == DataTypeHandler:
            _self = None
        else:
            _self = self
        this = _libdatatype.new_DataTypeHandler(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libdatatype.delete_DataTypeHandler
    __del__ = lambda self : None;
    def type(self, *args):
        """
        type(DataTypeHandler self, DFF::Node * arg0) -> std::string

        1
        """
        return _libdatatype.DataTypeHandler_type(self, *args)

    def __disown__(self):
        self.this.disown()
        _libdatatype.disown_DataTypeHandler(self)
        return weakref_proxy(self)
DataTypeHandler_swigregister = _libdatatype.DataTypeHandler_swigregister
DataTypeHandler_swigregister(DataTypeHandler)

class Type(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Type, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Type, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::Type self, std::string const name) -> Type

        1
        """
        this = _libdatatype.new_Type(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libdatatype.delete_Type
    __del__ = lambda self : None;
    def name(self):
        """
        name(Type self) -> std::string const

        1
        """
        return _libdatatype.Type_name(self)

    def compatibleModules(self):
        """
        compatibleModules(Type self) -> std::list< std::string,std::allocator< std::string > > const

        1
        """
        return _libdatatype.Type_compatibleModules(self)

Type_swigregister = _libdatatype.Type_swigregister
Type_swigregister(Type)

class DataTypeManager(dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataTypeManager, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataTypeManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Get():
        """
        Get() -> DataTypeManager

        1
        """
        return _libdatatype.DataTypeManager_Get()

    if _newclass:Get = staticmethod(Get)
    __swig_getmethods__["Get"] = lambda x: Get
    def Event(self, *args):
        """
        Event(DataTypeManager self, event e)

        1
        """
        return _libdatatype.DataTypeManager_Event(self, *args)

    def registerHandler(self, *args):
        """
        registerHandler(DataTypeManager self, DataTypeHandler dataTypeHandler) -> bool

        1
        """
        return _libdatatype.DataTypeManager_registerHandler(self, *args)

    def type(self, *args):
        """
        type(DataTypeManager self, DFF::Node * node) -> std::string const

        1
        """
        return _libdatatype.DataTypeManager_type(self, *args)

    def existingTypes(self):
        """
        existingTypes(DataTypeManager self) -> std::list< std::string,std::allocator< std::string > > const

        1
        """
        return _libdatatype.DataTypeManager_existingTypes(self)

    def nodes(self, *args):
        """
        nodes(DataTypeManager self, std::string type) -> std::vector< DFF::Node *,std::allocator< DFF::Node * > > const

        1
        """
        return _libdatatype.DataTypeManager_nodes(self, *args)

    def nodesCount(self, *args):
        """
        nodesCount(DataTypeManager self, std::string type) -> uint64_t

        1
        """
        return _libdatatype.DataTypeManager_nodesCount(self, *args)

    def compatibleModules(self, *args):
        """
        compatibleModules(DataTypeManager self, DFF::Node * node) -> std::list< std::string,std::allocator< std::string > >

        1
        """
        return _libdatatype.DataTypeManager_compatibleModules(self, *args)

DataTypeManager_swigregister = _libdatatype.DataTypeManager_swigregister
DataTypeManager_swigregister(DataTypeManager)

def DataTypeManager_Get():
  """
    DataTypeManager_Get() -> DataTypeManager

    1
    """
  return _libdatatype.DataTypeManager_Get()

class ListDataType(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListDataType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListDataType, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(ListDataType self) -> SwigPyIterator

        1
        """
        return _libdatatype.ListDataType_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(ListDataType self) -> bool

        1
        """
        return _libdatatype.ListDataType___nonzero__(self)

    def __bool__(self):
        """
        __bool__(ListDataType self) -> bool

        1
        """
        return _libdatatype.ListDataType___bool__(self)

    def __len__(self):
        """
        __len__(ListDataType self) -> std::list< DFF::DataTypeHandler * >::size_type

        1
        """
        return _libdatatype.ListDataType___len__(self)

    def pop(self):
        """
        pop(ListDataType self) -> DataTypeHandler

        1
        """
        return _libdatatype.ListDataType_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i, std::list< DFF::DataTypeHandler * >::difference_type j) -> ListDataType

        1
        """
        return _libdatatype.ListDataType___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i, std::list< DFF::DataTypeHandler * >::difference_type j, 
            ListDataType v=std::list< DFF::DataTypeHandler *,std::allocator< DFF::DataTypeHandler * > >())
        __setslice__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i, std::list< DFF::DataTypeHandler * >::difference_type j)

        1
        """
        return _libdatatype.ListDataType___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i, std::list< DFF::DataTypeHandler * >::difference_type j)

        1
        """
        return _libdatatype.ListDataType___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i)
        __delitem__(ListDataType self, PySliceObject * slice)

        1
        """
        return _libdatatype.ListDataType___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(ListDataType self, PySliceObject * slice) -> ListDataType
        __getitem__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i) -> DataTypeHandler

        1
        """
        return _libdatatype.ListDataType___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(ListDataType self, PySliceObject * slice, ListDataType v)
        __setitem__(ListDataType self, PySliceObject * slice)
        __setitem__(ListDataType self, std::list< DFF::DataTypeHandler * >::difference_type i, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType___setitem__(self, *args)

    def append(self, *args):
        """
        append(ListDataType self, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_append(self, *args)

    def empty(self):
        """
        empty(ListDataType self) -> bool

        1
        """
        return _libdatatype.ListDataType_empty(self)

    def size(self):
        """
        size(ListDataType self) -> std::list< DFF::DataTypeHandler * >::size_type

        1
        """
        return _libdatatype.ListDataType_size(self)

    def clear(self):
        """
        clear(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_clear(self)

    def swap(self, *args):
        """
        swap(ListDataType self, ListDataType v)

        1
        """
        return _libdatatype.ListDataType_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(ListDataType self) -> std::list< DFF::DataTypeHandler * >::allocator_type

        1
        """
        return _libdatatype.ListDataType_get_allocator(self)

    def begin(self):
        """
        begin(ListDataType self) -> std::list< DFF::DataTypeHandler * >::iterator

        1
        """
        return _libdatatype.ListDataType_begin(self)

    def end(self):
        """
        end(ListDataType self) -> std::list< DFF::DataTypeHandler * >::iterator

        1
        """
        return _libdatatype.ListDataType_end(self)

    def rbegin(self):
        """
        rbegin(ListDataType self) -> std::list< DFF::DataTypeHandler * >::reverse_iterator

        1
        """
        return _libdatatype.ListDataType_rbegin(self)

    def rend(self):
        """
        rend(ListDataType self) -> std::list< DFF::DataTypeHandler * >::reverse_iterator

        1
        """
        return _libdatatype.ListDataType_rend(self)

    def pop_back(self):
        """
        pop_back(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_pop_back(self)

    def erase(self, *args):
        """
        erase(ListDataType self, std::list< DFF::DataTypeHandler * >::iterator pos) -> std::list< DFF::DataTypeHandler * >::iterator
        erase(ListDataType self, std::list< DFF::DataTypeHandler * >::iterator first, std::list< DFF::DataTypeHandler * >::iterator last) -> std::list< DFF::DataTypeHandler * >::iterator

        1
        """
        return _libdatatype.ListDataType_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(p.DFF::DataTypeHandler)> self) -> ListDataType
        __init__(std::list<(p.DFF::DataTypeHandler)> self, ListDataType arg2) -> ListDataType
        __init__(std::list<(p.DFF::DataTypeHandler)> self, std::list< DFF::DataTypeHandler * >::size_type size) -> ListDataType
        __init__(std::list<(p.DFF::DataTypeHandler)> self, std::list< DFF::DataTypeHandler * >::size_type size, DataTypeHandler value) -> ListDataType

        1
        """
        this = _libdatatype.new_ListDataType(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(ListDataType self, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_push_back(self, *args)

    def front(self):
        """
        front(ListDataType self) -> DataTypeHandler

        1
        """
        return _libdatatype.ListDataType_front(self)

    def back(self):
        """
        back(ListDataType self) -> DataTypeHandler

        1
        """
        return _libdatatype.ListDataType_back(self)

    def assign(self, *args):
        """
        assign(ListDataType self, std::list< DFF::DataTypeHandler * >::size_type n, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_assign(self, *args)

    def resize(self, *args):
        """
        resize(ListDataType self, std::list< DFF::DataTypeHandler * >::size_type new_size)
        resize(ListDataType self, std::list< DFF::DataTypeHandler * >::size_type new_size, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_resize(self, *args)

    def insert(self, *args):
        """
        insert(ListDataType self, std::list< DFF::DataTypeHandler * >::iterator pos, DataTypeHandler x) -> std::list< DFF::DataTypeHandler * >::iterator
        insert(ListDataType self, std::list< DFF::DataTypeHandler * >::iterator pos, std::list< DFF::DataTypeHandler * >::size_type n, 
            DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_insert(self, *args)

    def pop_front(self):
        """
        pop_front(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_pop_front(self)

    def push_front(self, *args):
        """
        push_front(ListDataType self, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_push_front(self, *args)

    def remove(self, *args):
        """
        remove(ListDataType self, DataTypeHandler x)

        1
        """
        return _libdatatype.ListDataType_remove(self, *args)

    def unique(self):
        """
        unique(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_unique(self)

    def reverse(self):
        """
        reverse(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_reverse(self)

    def sort(self):
        """
        sort(ListDataType self)

        1
        """
        return _libdatatype.ListDataType_sort(self)

    def merge(self, *args):
        """
        merge(ListDataType self, ListDataType x)

        1
        """
        return _libdatatype.ListDataType_merge(self, *args)

    __swig_destroy__ = _libdatatype.delete_ListDataType
    __del__ = lambda self : None;
ListDataType_swigregister = _libdatatype.ListDataType_swigregister
ListDataType_swigregister(ListDataType)

class MapDataType(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapDataType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapDataType, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(MapDataType self) -> SwigPyIterator

        1
        """
        return _libdatatype.MapDataType_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(MapDataType self) -> bool

        1
        """
        return _libdatatype.MapDataType___nonzero__(self)

    def __bool__(self):
        """
        __bool__(MapDataType self) -> bool

        1
        """
        return _libdatatype.MapDataType___bool__(self)

    def __len__(self):
        """
        __len__(MapDataType self) -> std::map< std::string,unsigned int >::size_type

        1
        """
        return _libdatatype.MapDataType___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """
        __getitem__(MapDataType self, std::map< std::string,unsigned int >::key_type const & key) -> std::map< std::string,unsigned int >::mapped_type const &

        1
        """
        return _libdatatype.MapDataType___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(MapDataType self, std::map< std::string,unsigned int >::key_type const & key)

        1
        """
        return _libdatatype.MapDataType___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(MapDataType self, std::map< std::string,unsigned int >::key_type const & key) -> bool

        1
        """
        return _libdatatype.MapDataType_has_key(self, *args)

    def keys(self):
        """
        keys(MapDataType self) -> PyObject *

        1
        """
        return _libdatatype.MapDataType_keys(self)

    def values(self):
        """
        values(MapDataType self) -> PyObject *

        1
        """
        return _libdatatype.MapDataType_values(self)

    def items(self):
        """
        items(MapDataType self) -> PyObject *

        1
        """
        return _libdatatype.MapDataType_items(self)

    def __contains__(self, *args):
        """
        __contains__(MapDataType self, std::map< std::string,unsigned int >::key_type const & key) -> bool

        1
        """
        return _libdatatype.MapDataType___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(MapDataType self) -> SwigPyIterator

        1
        """
        return _libdatatype.MapDataType_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(MapDataType self) -> SwigPyIterator

        1
        """
        return _libdatatype.MapDataType_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(MapDataType self, std::map< std::string,unsigned int >::key_type const & key)
        __setitem__(MapDataType self, std::map< std::string,unsigned int >::key_type const & key, std::map< std::string,unsigned int >::mapped_type const & x)

        1
        """
        return _libdatatype.MapDataType___setitem__(self, *args)

    def asdict(self):
        """
        asdict(MapDataType self) -> PyObject *

        1
        """
        return _libdatatype.MapDataType_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,uint32_t)> self, std::less< std::string > const & arg2) -> MapDataType
        __init__(std::map<(std::string,uint32_t)> self) -> MapDataType
        __init__(std::map<(std::string,uint32_t)> self, MapDataType arg2) -> MapDataType

        1
        """
        this = _libdatatype.new_MapDataType(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(MapDataType self) -> bool

        1
        """
        return _libdatatype.MapDataType_empty(self)

    def size(self):
        """
        size(MapDataType self) -> std::map< std::string,unsigned int >::size_type

        1
        """
        return _libdatatype.MapDataType_size(self)

    def clear(self):
        """
        clear(MapDataType self)

        1
        """
        return _libdatatype.MapDataType_clear(self)

    def swap(self, *args):
        """
        swap(MapDataType self, MapDataType v)

        1
        """
        return _libdatatype.MapDataType_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(MapDataType self) -> std::map< std::string,unsigned int >::allocator_type

        1
        """
        return _libdatatype.MapDataType_get_allocator(self)

    def begin(self):
        """
        begin(MapDataType self) -> std::map< std::string,unsigned int >::iterator

        1
        """
        return _libdatatype.MapDataType_begin(self)

    def end(self):
        """
        end(MapDataType self) -> std::map< std::string,unsigned int >::iterator

        1
        """
        return _libdatatype.MapDataType_end(self)

    def rbegin(self):
        """
        rbegin(MapDataType self) -> std::map< std::string,unsigned int >::reverse_iterator

        1
        """
        return _libdatatype.MapDataType_rbegin(self)

    def rend(self):
        """
        rend(MapDataType self) -> std::map< std::string,unsigned int >::reverse_iterator

        1
        """
        return _libdatatype.MapDataType_rend(self)

    def count(self, *args):
        """
        count(MapDataType self, std::map< std::string,unsigned int >::key_type const & x) -> std::map< std::string,unsigned int >::size_type

        1
        """
        return _libdatatype.MapDataType_count(self, *args)

    def erase(self, *args):
        """
        erase(MapDataType self, std::map< std::string,unsigned int >::key_type const & x) -> std::map< std::string,unsigned int >::size_type
        erase(MapDataType self, std::map< std::string,unsigned int >::iterator position)
        erase(MapDataType self, std::map< std::string,unsigned int >::iterator first, std::map< std::string,unsigned int >::iterator last)

        1
        """
        return _libdatatype.MapDataType_erase(self, *args)

    def find(self, *args):
        """
        find(MapDataType self, std::map< std::string,unsigned int >::key_type const & x) -> std::map< std::string,unsigned int >::iterator

        1
        """
        return _libdatatype.MapDataType_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(MapDataType self, std::map< std::string,unsigned int >::key_type const & x) -> std::map< std::string,unsigned int >::iterator

        1
        """
        return _libdatatype.MapDataType_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(MapDataType self, std::map< std::string,unsigned int >::key_type const & x) -> std::map< std::string,unsigned int >::iterator

        1
        """
        return _libdatatype.MapDataType_upper_bound(self, *args)

    __swig_destroy__ = _libdatatype.delete_MapDataType
    __del__ = lambda self : None;
MapDataType_swigregister = _libdatatype.MapDataType_swigregister
MapDataType_swigregister(MapDataType)

# This file is compatible with both classic and new-style classes.


