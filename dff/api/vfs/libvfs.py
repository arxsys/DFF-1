# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
libvfs: c++ generated inteface
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libvfs', [dirname(__file__)])
        except ImportError:
            import _libvfs
            return _libvfs
        if fp is not None:
            try:
                _mod = imp.load_module('_libvfs', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libvfs = swig_import_helper()
    del swig_import_helper
else:
    import _libvfs
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libvfs.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """
        value(SwigPyIterator self) -> PyObject *

        1
        """
        return _libvfs.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        1
        """
        return _libvfs.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        1
        """
        return _libvfs.SwigPyIterator_equal(self, *args)

    def copy(self):
        """
        copy(SwigPyIterator self) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator_copy(self)

    def next(self):
        """
        next(SwigPyIterator self) -> PyObject *

        1
        """
        return _libvfs.SwigPyIterator_next(self)

    def __next__(self):
        """
        __next__(SwigPyIterator self) -> PyObject *

        1
        """
        return _libvfs.SwigPyIterator___next__(self)

    def previous(self):
        """
        previous(SwigPyIterator self) -> PyObject *

        1
        """
        return _libvfs.SwigPyIterator_previous(self)

    def advance(self, *args):
        """
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        1
        """
        return _libvfs.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        1
        """
        return _libvfs.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        1
        """
        return _libvfs.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        1
        """
        return _libvfs.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _libvfs.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import dff.api.exceptions.libexceptions
import dff.api.types.libtypes
import dff.api.events.libevents
class Color(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Color, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Color, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::Color self) -> Color
        __init__(DFF::Color self, uint8_t r, uint8_t g, uint8_t b) -> Color

        1
        """
        this = _libvfs.new_Color(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["r"] = _libvfs.Color_r_set
    __swig_getmethods__["r"] = _libvfs.Color_r_get
    if _newclass:r = _swig_property(_libvfs.Color_r_get, _libvfs.Color_r_set)
    __swig_setmethods__["g"] = _libvfs.Color_g_set
    __swig_getmethods__["g"] = _libvfs.Color_g_get
    if _newclass:g = _swig_property(_libvfs.Color_g_get, _libvfs.Color_g_set)
    __swig_setmethods__["b"] = _libvfs.Color_b_set
    __swig_getmethods__["b"] = _libvfs.Color_b_get
    if _newclass:b = _swig_property(_libvfs.Color_b_get, _libvfs.Color_b_set)
    __swig_destroy__ = _libvfs.delete_Color
    __del__ = lambda self : None;
Color_swigregister = _libvfs.Color_swigregister
Color_swigregister(Color)

class Tag(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tag, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libvfs.delete_Tag
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(DFF::Tag self) -> Tag
        __init__(DFF::Tag self, uint32_t id, std::string const arg3, Color color) -> Tag
        __init__(DFF::Tag self, uint32_t id, std::string const arg3, uint8_t r, uint8_t g, uint8_t b) -> Tag

        1
        """
        this = _libvfs.new_Tag(*args)
        try: self.this.append(this)
        except: self.this = this
    def id(self):
        """
        id(Tag self) -> uint32_t

        1
        """
        return _libvfs.Tag_id(self)

    def name(self):
        """
        name(Tag self) -> std::string const

        1
        """
        return _libvfs.Tag_name(self)

    def color(self):
        """
        color(Tag self) -> Color

        1
        """
        return _libvfs.Tag_color(self)

    def setColor(self, *args):
        """
        setColor(Tag self, Color color)
        setColor(Tag self, uint8_t r, uint8_t g, uint8_t b)

        1
        """
        return _libvfs.Tag_setColor(self, *args)

    def setName(self, *args):
        """
        setName(Tag self, std::string const name)

        1
        """
        return _libvfs.Tag_setName(self, *args)

Tag_swigregister = _libvfs.Tag_swigregister
Tag_swigregister(Tag)

class TagsManager(dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagsManager, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TagsManager, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def get():
        """
        get() -> TagsManager

        1
        """
        return _libvfs.TagsManager_get()

    if _newclass:get = staticmethod(get)
    __swig_getmethods__["get"] = lambda x: get
    def Event(self, *args):
        """
        Event(TagsManager self, event e)

        1
        """
        return _libvfs.TagsManager_Event(self, *args)

    def addNode(self, *args):
        """
        addNode(TagsManager self, uint32_t tagId, uint64_t nodeUid) -> bool

        1
        """
        return _libvfs.TagsManager_addNode(self, *args)

    def removeNode(self, *args):
        """
        removeNode(TagsManager self, uint32_t tagId, uint64_t nodeUid) -> bool

        1
        """
        return _libvfs.TagsManager_removeNode(self, *args)

    def nodesCount(self, *args):
        """
        nodesCount(TagsManager self, std::string const name) -> uint64_t
        nodesCount(TagsManager self, uint32_t tagId) -> uint64_t

        1
        """
        return _libvfs.TagsManager_nodesCount(self, *args)

    def nodes(self, *args):
        """
        nodes(TagsManager self, std::string const name) -> Listui64
        nodes(TagsManager self, uint32_t tagId) -> Listui64

        1
        """
        return _libvfs.TagsManager_nodes(self, *args)

    def tag(self, *args):
        """
        tag(TagsManager self, uint32_t id) -> Tag
        tag(TagsManager self, std::string const name) -> Tag

        1
        """
        return _libvfs.TagsManager_tag(self, *args)

    def tags(self):
        """
        tags(TagsManager self) -> TagVect

        1
        """
        return _libvfs.TagsManager_tags(self)

    def add(self, *args):
        """
        add(TagsManager self, std::string const name) -> uint32_t
        add(TagsManager self, std::string const name, Color color) -> uint32_t
        add(TagsManager self, std::string const name, uint8_t r, uint8_t g, uint8_t b) -> uint32_t

        1
        """
        return _libvfs.TagsManager_add(self, *args)

    def remove(self, *args):
        """
        remove(TagsManager self, uint32_t id) -> bool
        remove(TagsManager self, std::string const name) -> bool

        1
        """
        return _libvfs.TagsManager_remove(self, *args)

TagsManager_swigregister = _libvfs.TagsManager_swigregister
TagsManager_swigregister(TagsManager)

def TagsManager_get():
  """
    TagsManager_get() -> TagsManager

    1
    """
  return _libvfs.TagsManager_get()

class NodeManager(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NodeManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodeManager, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(DFF::NodeManager self) -> NodeManager

        1
        """
        this = _libvfs.new_NodeManager()
        try: self.this.append(this)
        except: self.this = this
    def uid(self, *args):
        """
        uid(NodeManager self, Node node) -> uint64_t

        1
        """
        return _libvfs.NodeManager_uid(self, *args)

    def remove(self, *args):
        """
        remove(NodeManager self, uint64_t uid) -> bool
        remove(NodeManager self, Node node) -> bool

        1
        """
        return _libvfs.NodeManager_remove(self, *args)

    def node(self, *args):
        """
        node(NodeManager self, uint64_t uid) -> Node

        1
        """
        return _libvfs.NodeManager_node(self, *args)

    def orphansCount(self):
        """
        orphansCount(NodeManager self) -> uint64_t

        1
        """
        return _libvfs.NodeManager_orphansCount(self)

    __swig_destroy__ = _libvfs.delete_NodeManager
    __del__ = lambda self : None;
NodeManager_swigregister = _libvfs.NodeManager_swigregister
NodeManager_swigregister(NodeManager)

class VFS(dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VFS, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VFS, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["cwd"] = _libvfs.VFS_cwd_set
    __swig_getmethods__["cwd"] = _libvfs.VFS_cwd_get
    if _newclass:cwd = _swig_property(_libvfs.VFS_cwd_get, _libvfs.VFS_cwd_set)
    __swig_setmethods__["root"] = _libvfs.VFS_root_set
    __swig_getmethods__["root"] = _libvfs.VFS_root_get
    if _newclass:root = _swig_property(_libvfs.VFS_root_get, _libvfs.VFS_root_set)
    def Get():
        """
        Get() -> VFS

        1
        """
        return _libvfs.VFS_Get()

    if _newclass:Get = staticmethod(Get)
    __swig_getmethods__["Get"] = lambda x: Get
    def registerNode(self, *args):
        """
        registerNode(VFS self, Node n) -> uint64_t

        1
        """
        return _libvfs.VFS_registerNode(self, *args)

    def registerFsobj(self, *args):
        """
        registerFsobj(VFS self, fso fsobj) -> uint16_t

        1
        """
        return _libvfs.VFS_registerFsobj(self, *args)

    def unregister(self, *args):
        """
        unregister(VFS self, Node node) -> bool

        1
        """
        return _libvfs.VFS_unregister(self, *args)

    def Event(self, *args):
        """
        Event(VFS self, event e)

        1
        """
        return _libvfs.VFS_Event(self, *args)

    def cd(self, *args):
        """
        cd(VFS self, Node arg2)

        1
        """
        return _libvfs.VFS_cd(self, *args)

    def GetCWD(self):
        """
        GetCWD(VFS self) -> Node

        1
        """
        return _libvfs.VFS_GetCWD(self)

    def GetNode(self, *args):
        """
        GetNode(VFS self, std::string path) -> Node
        GetNode(VFS self, std::string path, Node where) -> Node

        1
        """
        return _libvfs.VFS_GetNode(self, *args)

    def fsobjs(self):
        """
        fsobjs(VFS self) -> FsoVect

        1
        """
        return _libvfs.VFS_fsobjs(self)

    def totalNodes(self):
        """
        totalNodes(VFS self) -> uint64_t

        1
        """
        return _libvfs.VFS_totalNodes(self)

    def getNodeById(self, *args):
        """
        getNodeById(VFS self, uint64_t id) -> Node

        1
        """
        return _libvfs.VFS_getNodeById(self, *args)

VFS_swigregister = _libvfs.VFS_swigregister
VFS_swigregister(VFS)

def VFS_Get():
  """
    VFS_Get() -> VFS

    1
    """
  return _libvfs.VFS_Get()

class chunk(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, chunk, name)
    __repr__ = _swig_repr
    __swig_setmethods__["offset"] = _libvfs.chunk_offset_set
    __swig_getmethods__["offset"] = _libvfs.chunk_offset_get
    if _newclass:offset = _swig_property(_libvfs.chunk_offset_get, _libvfs.chunk_offset_set)
    __swig_setmethods__["size"] = _libvfs.chunk_size_set
    __swig_getmethods__["size"] = _libvfs.chunk_size_get
    if _newclass:size = _swig_property(_libvfs.chunk_size_get, _libvfs.chunk_size_set)
    __swig_setmethods__["origin"] = _libvfs.chunk_origin_set
    __swig_getmethods__["origin"] = _libvfs.chunk_origin_get
    if _newclass:origin = _swig_property(_libvfs.chunk_origin_get, _libvfs.chunk_origin_set)
    __swig_setmethods__["originoffset"] = _libvfs.chunk_originoffset_set
    __swig_getmethods__["originoffset"] = _libvfs.chunk_originoffset_get
    if _newclass:originoffset = _swig_property(_libvfs.chunk_originoffset_get, _libvfs.chunk_originoffset_set)
    def __init__(self): 
        """
        __init__(DFF::chunk self) -> chunk

        1
        """
        this = _libvfs.new_chunk()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_chunk
    __del__ = lambda self : None;
chunk_swigregister = _libvfs.chunk_swigregister
chunk_swigregister(chunk)

class FileMapping(_object):
    """
    Most of the time (with a few exceptions), nodes in DFF are associated with a set of meta-data
    and a content. For example, a file system driver will parse the real file system of a dump
    or device and then create one node for each files and directories. These files are associated
    with content, such as pictures, text, videos, etc. The content of a file is located somewhere
    on the dump and can be found by following the file system specification. For each modules, the
    specification is different so file content position will be different.

    As far as each file systems and dumps do not have the same specification and content, it is necessary
    to have a standard way to represent their content position in DFF.

    The FileMapping class is used to give this standard way to describe file content positions on the dump.
    So when the file is opened its content can be displayed in DFF interface using a viewer.
    File content can be fragmented on the disk so generally there are several chunks to describe the
    entire content of a file, especially on big files.

    More precisely, the FileMapping class contains a list of chunks giving the different offsets
    of the file blocks on the vfile. Each chunks are used to describe one of these different positions on the vfile
    by providing two informations :
        * the offset of the data on the vfile
        * the size it occupies

    In other words, the chunk's list will, for each areas the file occupies, give its begining offset and its size.
    We could say something like :
     * The file `foo` first chunk start at offset 0x42 and occupies 10 bytes.
     * The second chunk of `foo` file starts at offset 0x84 and occupies 20 bytes.
     * etc.
     
    For example, lets imagine we open a 100 bytes big node which is fragmented in
    three parts. When mapping the file, three chunks will be created and will look
    like this :
        * chunk 1 => offset : x; size : s bytes
        * chunk 1 => offset : y; size : t bytes
        * chunk 1 => offset : z; size : u bytes

    The sum `s + t + u` should be equal to the file size (100 bytes in our example).
    The "main" method of FileMapping class is push, which must be called to
    create the different chunks. This method muts be called in the Node::fileMapping method,
    which is called by DFF when the node is opened.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileMapping, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileMapping, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::FileMapping self, Node node) -> FileMapping

        1
        """
        this = _libvfs.new_FileMapping(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_FileMapping
    __del__ = lambda self : None;
    def addref(self):
        """
        addref(FileMapping self)

        1
        """
        return _libvfs.FileMapping_addref(self)

    def delref(self):
        """
        delref(FileMapping self)

        1
        """
        return _libvfs.FileMapping_delref(self)

    def refcount(self):
        """
        refcount(FileMapping self) -> uint64_t

        1
        """
        return _libvfs.FileMapping_refcount(self)

    def node(self):
        """
        node(FileMapping self) -> Node

        1
        """
        return _libvfs.FileMapping_node(self)

    def maxOffset(self):
        """
        maxOffset(FileMapping self) -> uint64_t

        1
        """
        return _libvfs.FileMapping_maxOffset(self)

    def chunkFromOffset(self, *args):
        """
        chunkFromOffset(FileMapping self, uint64_t offset) -> chunk

        Return a pointer to the chunk in which offset `offset` is.

        """
        return _libvfs.FileMapping_chunkFromOffset(self, *args)

    def push(self, *args):
        """
        push(FileMapping self, uint64_t offset, uint64_t size, Node origin=None, uint64_t originoffset=0, bool force=False)
        push(FileMapping self, uint64_t offset, uint64_t size, Node origin=None, uint64_t originoffset=0)
        push(FileMapping self, uint64_t offset, uint64_t size, Node origin=None)
        push(FileMapping self, uint64_t offset, uint64_t size)

        1
        """
        return _libvfs.FileMapping_push(self, *args)

    def chunkCount(self):
        """
        chunkCount(FileMapping self) -> uint32_t

        Return the number of mapped chunks.

        """
        return _libvfs.FileMapping_chunkCount(self)

    def firstChunk(self):
        """
        firstChunk(FileMapping self) -> chunk

        Return a pointer to the first chunk of the list.

        """
        return _libvfs.FileMapping_firstChunk(self)

    def lastChunk(self):
        """
        lastChunk(FileMapping self) -> chunk

        Return a pointer to the last chunk of the list.

        """
        return _libvfs.FileMapping_lastChunk(self)

    def chunkIdxFromOffset(self, *args):
        """
        chunkIdxFromOffset(FileMapping self, uint64_t offset, uint32_t begidx=0) -> uint32_t
        chunkIdxFromOffset(FileMapping self, uint64_t offset) -> uint32_t

        1
        """
        return _libvfs.FileMapping_chunkIdxFromOffset(self, *args)

    def chunksFromOffsetRange(self, *args):
        """
        chunksFromOffsetRange(FileMapping self, uint64_t begoffset, uint64_t endoffset) -> VectChunk

        1
        """
        return _libvfs.FileMapping_chunksFromOffsetRange(self, *args)

    def chunks(self):
        """
        chunks(FileMapping self) -> VectChunk

        1
        """
        return _libvfs.FileMapping_chunks(self)

FileMapping_swigregister = _libvfs.FileMapping_swigregister
FileMapping_swigregister(FileMapping)

class fso(_object):
    """
    The fso or 'File System Object' class is the base class of the API. All
    modules must inheritates it (or inherit mfso, which itself inherit fso). It provides
    several virtual methods which must be reimplemented, such as start, vopen, vread, vwrite, 
    vclose and vseek. They are used to read, open, write and seek within the content
    of a node.
            
    The start method does the job the module is supposed to do. This is the method which is
    called when a module is launched.

    The main difference between fso and mfso is the fact that the open, read and seek method
    are pure virtual in fso and virtual in mfso. Indeed, using the fso class rather than
    the mfso class, where implentations of open and read are provided, supposes that the
    developer of the module does not wish to use the FileMapping system.

    The behaviour, use and prototype of methods open, read and seek are pretty similar to their
    UNIX equivalent. The vwrite method is generally not used, and even left empty in modules implementations.


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fso, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fso, name)
    __repr__ = _swig_repr
    __swig_setmethods__["res"] = _libvfs.fso_res_set
    __swig_getmethods__["res"] = _libvfs.fso_res_get
    if _newclass:res = _swig_property(_libvfs.fso_res_get, _libvfs.fso_res_set)
    __swig_setmethods__["stateinfo"] = _libvfs.fso_stateinfo_set
    __swig_getmethods__["stateinfo"] = _libvfs.fso_stateinfo_get
    if _newclass:stateinfo = _swig_property(_libvfs.fso_stateinfo_get, _libvfs.fso_stateinfo_set)
    __swig_setmethods__["name"] = _libvfs.fso_name_set
    __swig_getmethods__["name"] = _libvfs.fso_name_get
    if _newclass:name = _swig_property(_libvfs.fso_name_get, _libvfs.fso_name_set)
    def __init__(self, *args): 
        """
        __init__(DFF::fso self, std::string name) -> fso

        1
        """
        if self.__class__ == fso:
            _self = None
        else:
            _self = self
        this = _libvfs.new_fso(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_fso
    __del__ = lambda self : None;
    def start(self, *args):
        """
        start(fso self, VMap args)

        This method is called when the module starts. It does the job the module
        is supposed to do. This method is declared as a pure virtual so each modules
        must reiplements it (see the developer's documentations for more details) in
        python or C++, depending on which language you choose.

        The parameter 'args' is a pointer to the arguments list which were passed to the
        module when it was launched. You can get them by using the method
         args->get("arg_name", &variable)
        where variable must be of the same type than the argument "arg_name"

        If you create nodes, you must not forget to call the method register_tree at
        the end of the module execution.

        If an error occured while getting a parameter, a envError exception is thrown.

        Params :
                * args : the list of arguments passed to the module.


        """
        return _libvfs.fso_start(self, *args)

    def vopen(self, *args):
        """
        vopen(fso self, Node n) -> int32_t

        Open a node.

        Param :
                * n : the node you want to open

        Return the opened file descriptor, or 0 if it failed.

        """
        return _libvfs.fso_vopen(self, *args)

    def vread(self, *args):
        """
        vread(fso self, int32_t fd, void * rbuff, uint32_t size) -> int32_t

        vread(self, int32_t fd, void rbuff, uint32_t size) -> int32_t

        Perform readings on an open node and returns the number of bytes which wereread.

        Params :
                * fd : the file descriptor of the node you want to read on.
                * rbuff : a pointer to an allocated buffer where the read bytes will be stored
                * size : the number of characters you want to read.

        Return the number of read characters.

        """
        return _libvfs.fso_vread(self, *args)

    def vwrite(self, *args):
        """
        vwrite(fso self, int32_t fd, void * wbuff, uint32_t size) -> int32_t

        Not used.

        """
        return _libvfs.fso_vwrite(self, *args)

    def vclose(self, *args):
        """
        vclose(fso self, int32_t fd) -> int32_t

        Close an open file descriptor and make it available again for others
        openings.

        Return `0` if everything went fine, `0` otherwise.

        """
        return _libvfs.fso_vclose(self, *args)

    def vseek(self, *args):
        """
        vseek(fso self, int32_t fd, uint64_t offset, int32_t whence) -> uint64_t

        vseek(self, int32_t fd, uint64_t offset, int32_t whence) -> uint64_t

        This method is used to change position within an open node (i.e. modifies the
        offset of the current position). The offset is set to 0 when the file is open.

        Throws a vfsError if something goes wrong (typically if the seeking position is
        after the end of the file).

        It takes three parameters :
                * a file descriptor of an open node
                * the offset where you want to seek
                * the third parameter is optional : it defines if the offset passed in second parameter is absolute or relative.

        Return an uint64_t

        """
        return _libvfs.fso_vseek(self, *args)

    def status(self):
        """
        status(fso self) -> uint32_t

        Return the status of the module.

        """
        return _libvfs.fso_status(self)

    def vtell(self, *args):
        """
        vtell(fso self, int32_t fd) -> uint64_t

        Returns the current offset in a file.

        """
        return _libvfs.fso_vtell(self, *args)

    def setVerbose(self, *args):
        """
        setVerbose(fso self, bool verbose)

        Set the module in verbose mode if the param `verbose` is et to `true`, 
        shutdown the verbose mode otherwise. Verbose mode should not be enabled
        in production environment.

        Params :
                * verbose : the verbosity

        """
        return _libvfs.fso_setVerbose(self, *args)

    def verbose(self):
        """
        verbose(fso self) -> bool

        Return `true` if the module is in verbose mode, `false` otherwise.

        """
        return _libvfs.fso_verbose(self)

    def registerTree(self, *args):
        """
        registerTree(fso self, Node parent, Node head)

        1
        """
        return _libvfs.fso_registerTree(self, *args)

    def registerNode(self, *args):
        """
        registerNode(fso self, uint64_t id, Node node) -> uint64_t

        1
        """
        return _libvfs.fso_registerNode(self, *args)

    def nodes(self):
        """
        nodes(fso self) -> VecNode

        1
        """
        return _libvfs.fso_nodes(self)

    def nodeCount(self):
        """
        nodeCount(fso self) -> uint64_t

        1
        """
        return _libvfs.fso_nodeCount(self)

    def uid(self):
        """
        uid(fso self) -> uint16_t

        1
        """
        return _libvfs.fso_uid(self)

    def getNodeById(self, *args):
        """
        getNodeById(fso self, uint64_t id) -> Node

        1
        """
        return _libvfs.fso_getNodeById(self, *args)

    def hasChildren(self):
        """
        hasChildren(fso self) -> bool

        1
        """
        return _libvfs.fso_hasChildren(self)

    def children(self):
        """
        children(fso self) -> FsoVect

        1
        """
        return _libvfs.fso_children(self)

    def childCount(self):
        """
        childCount(fso self) -> uint32_t

        1
        """
        return _libvfs.fso_childCount(self)

    def setParent(self, *args):
        """
        setParent(fso self, fso parent)

        1
        """
        return _libvfs.fso_setParent(self, *args)

    def parent(self):
        """
        parent(fso self) -> fso

        1
        """
        return _libvfs.fso_parent(self)

    def addChild(self, *args):
        """
        addChild(fso self, fso child)

        1
        """
        return _libvfs.fso_addChild(self, *args)

    def unmap(self, *args):
        """
        unmap(fso self, Node node) -> bool

        1
        """
        return _libvfs.fso_unmap(self, *args)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_fso(self)
        return weakref_proxy(self)
fso_swigregister = _libvfs.fso_swigregister
fso_swigregister(fso)

class mfso(fso):
    """
    The mfso purpose has pretty the same role as the fso one. It inheritates fso.

    The main difference is based on the file mapping : the fso class
    do not use file mapping, mfso uses it. The mfso class provides implementations
    for the vopen, vread and vseek methods and a file descriptor manager (which not
    the case in the fso interface). It provides an abstraction of the node's content
    to developers, making the code easier to write.

    File mapping is detailed in libvfs.fileMapping.

    """
    __swig_setmethods__ = {}
    for _s in [fso]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, mfso, name, value)
    __swig_getmethods__ = {}
    for _s in [fso]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, mfso, name)
    __repr__ = _swig_repr
    __swig_setmethods__["__fdmanager"] = _libvfs.mfso___fdmanager_set
    __swig_getmethods__["__fdmanager"] = _libvfs.mfso___fdmanager_get
    if _newclass:__fdmanager = _swig_property(_libvfs.mfso___fdmanager_get, _libvfs.mfso___fdmanager_set)
    def __init__(self, *args): 
        """
        __init__(DFF::mfso self, std::string name) -> mfso

        1
        """
        if self.__class__ == mfso:
            _self = None
        else:
            _self = self
        this = _libvfs.new_mfso(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_mfso
    __del__ = lambda self : None;
    def start(self, *args):
        """
        start(mfso self, VMap args)

        start(self, argument args)

        This method is pure virtual in mfso so musts be implemented while developing
        a module.

        This method is called when the module starts. It does the job the module
        is supposed to do. This method is declared as a pure virtual so each modules
        must reiplements it (see the developer's documentations for more details) in
        python or C++, depending on which language you choose.

        The parameter 'args' is pointer to the arguments list which were passed to the
        module when it was launched. You can get them by using the method

          args->get("arg_name", &variable)

        where variable must be of the same type than the argument "arg_name"

        If you create nodes, you must not forget to call the method register_tree at
        the end of the module execution.

        If an error occured while getting a parameter, a envError exception is thrown.

        Params :
                * args : the list of arguments.


        """
        return _libvfs.mfso_start(self, *args)

    def vopen(self, *args):
        """
        vopen(mfso self, Node n) -> int32_t

        Open a node.

        Param :
                * n : the node you want to open

        Return the opened file descriptor, or 0 if it failed.

        """
        return _libvfs.mfso_vopen(self, *args)

    def vread(self, *args):
        """
        vread(mfso self, int32_t fd, void * rbuff, uint32_t size) -> int32_t

        Perform readings on an open node and returns the number of bytes which were read.
        The reading is performed at the current offset on the file. If the user tries
        to read more bytes that they are in the file, read will stop reading at the
        end of the file and return the actual number of read characters.

        Params :
                * fd : the file descroiptor of the node you want to read on.
                * buff : a pointer to an allocated buffer where the read bytes will be stored
                * size : the number of characters you want to read.

        Throw a vfsError if something goes wrong.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Return the number of read characters.

        """
        return _libvfs.mfso_vread(self, *args)

    def vwrite(self, *args):
        """
        vwrite(mfso self, int32_t fd, void * buff, uint32_t size) -> int32_t

        Not used in most cases.

        """
        return _libvfs.mfso_vwrite(self, *args)

    def vclose(self, *args):
        """
        vclose(mfso self, int32_t fd) -> int32_t

        Close an open file descriptor and make it available again for others
        openings.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Params :
                * fd : the file decsriptor you want to close.

        Return 0.


        """
        return _libvfs.mfso_vclose(self, *args)

    def vseek(self, *args):
        """
        vseek(mfso self, int32_t fd, uint64_t offset, int32_t whence) -> uint64_t

        This method is used to change offset within an open node.
        The offset is set to 0 when the file is open.

        Throws a vfsError if something goes wrong (typically if the seeking position is
        after the end of the file).

        Params :
                * fd : a file descriptor of an open node
                * offset : the offset where you want to seek
                * whence : the third parameter is optional : it defines if the offset passed in second parameter is absolute or relative.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Return of how many bytes the position changed.

        """
        return _libvfs.mfso_vseek(self, *args)

    def status(self):
        """
        status(mfso self) -> uint32_t

        Return the status of the module.

        """
        return _libvfs.mfso_status(self)

    def vtell(self, *args):
        """
        vtell(mfso self, int32_t fd) -> uint64_t

        Returns the current offset in a file.

        An implentation of this method is provided with mfso, so developers should not have
        to reimplement it.

        Param :
                * fd : the file descriptor of the node on which you want to use vtell.


        """
        return _libvfs.mfso_vtell(self, *args)

    def setVerbose(self, *args):
        """
        setVerbose(mfso self, bool verbose)

        setVerbose(self, bool verbose)

        Set the module in verbose mode if the param `verbose` is set to `true`, 
        shutdown the verbose mode otherwise.

        """
        return _libvfs.mfso_setVerbose(self, *args)

    def verbose(self):
        """
        verbose(mfso self) -> bool

        verbose(self) -> bool

        Return `true` if the module is in verbose mode, `false` otherwise.

        """
        return _libvfs.mfso_verbose(self)

    def unmap(self, *args):
        """
        unmap(mfso self, Node node) -> bool

        1
        """
        return _libvfs.mfso_unmap(self, *args)

    def vread(self, *args):
      return (_libvfs.mfso_vread(self, *args),)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_mfso(self)
        return weakref_proxy(self)
mfso_swigregister = _libvfs.mfso_swigregister
mfso_swigregister(mfso)

BUFFSIZE = _libvfs.BUFFSIZE
class pdata(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, pdata, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, pdata, name)
    __repr__ = _swig_repr
    __swig_setmethods__["buff"] = _libvfs.pdata_buff_set
    __swig_getmethods__["buff"] = _libvfs.pdata_buff_get
    if _newclass:buff = _swig_property(_libvfs.pdata_buff_get, _libvfs.pdata_buff_set)
    __swig_setmethods__["len"] = _libvfs.pdata_len_set
    __swig_getmethods__["len"] = _libvfs.pdata_len_get
    if _newclass:len = _swig_property(_libvfs.pdata_len_get, _libvfs.pdata_len_set)
    def __init__(self): 
        """
        __init__(DFF::pdata self) -> pdata

        1
        """
        this = _libvfs.new_pdata()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_pdata
    __del__ = lambda self : None;
pdata_swigregister = _libvfs.pdata_swigregister
pdata_swigregister(pdata)

class VFile(dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VFile, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VFile, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::VFile self, int32_t fd, fso fsobj, Node node) -> VFile

        1
        """
        this = _libvfs.new_VFile(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_VFile
    __del__ = lambda self : None;
    def node(self):
        """
        node(VFile self) -> Node

        1
        """
        return _libvfs.VFile_node(self)

    def read(self, *args):
        """
        read(VFile self) -> pdata
        read(VFile self, uint32_t size) -> pdata
        read(VFile self, void * buff, uint32_t size) -> int32_t

        1
        """
        return _libvfs.VFile_read(self, *args)

    def seek(self, *args):
        """
        seek(VFile self, uint64_t offset, char * whence) -> uint64_t
        seek(VFile self, uint64_t offset, int32_t whence) -> uint64_t
        seek(VFile self, uint64_t offset) -> uint64_t
        seek(VFile self, int32_t offset, int32_t whence) -> uint64_t

        1
        """
        return _libvfs.VFile_seek(self, *args)

    def write(self, *args):
        """
        write(VFile self, std::string buff) -> int32_t
        write(VFile self, char * buff, uint32_t size) -> int32_t

        1
        """
        return _libvfs.VFile_write(self, *args)

    def dfileno(self):
        """
        dfileno(VFile self) -> int32_t

        1
        """
        return _libvfs.VFile_dfileno(self)

    def tell(self):
        """
        tell(VFile self) -> uint64_t

        1
        """
        return _libvfs.VFile_tell(self)

    def close(self):
        """
        close(VFile self) -> int32_t

        1
        """
        return _libvfs.VFile_close(self)

    def Event(self, *args):
        """
        Event(VFile self, event e)

        1
        """
        return _libvfs.VFile_Event(self, *args)

    def readline(self, size=0):
        """
        readline(VFile self, uint32_t size=0) -> std::string
        readline(VFile self) -> std::string

        1
        """
        return _libvfs.VFile_readline(self, size)

    def search(self, *args):
        """
        search(VFile self, char * needle, uint32_t nlen, unsigned char wildcard='\0', uint64_t start=0, uint64_t end=UINT64_MAX) -> Vectui64
        search(VFile self, char * needle, uint32_t nlen, unsigned char wildcard='\0', uint64_t start=0) -> Vectui64
        search(VFile self, char * needle, uint32_t nlen, unsigned char wildcard='\0') -> Vectui64
        search(VFile self, char * needle, uint32_t nlen) -> Vectui64

        1
        """
        return _libvfs.VFile_search(self, *args)

    def find(self, *args):
        """
        find(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0, uint64_t end=UINT64_MAX) -> int64_t
        find(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0) -> int64_t
        find(VFile self, std::string needle, unsigned char wildcard='\0') -> int64_t
        find(VFile self, std::string needle) -> int64_t
        find(VFile self, DFF::Search * sctx, uint64_t start=0, uint64_t end=UINT64_MAX) -> int64_t
        find(VFile self, DFF::Search * sctx, uint64_t start=0) -> int64_t
        find(VFile self, DFF::Search * sctx) -> int64_t

        1
        """
        return _libvfs.VFile_find(self, *args)

    def rfind(self, *args):
        """
        rfind(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0, uint64_t end=UINT64_MAX) -> int64_t
        rfind(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0) -> int64_t
        rfind(VFile self, std::string needle, unsigned char wildcard='\0') -> int64_t
        rfind(VFile self, std::string needle) -> int64_t
        rfind(VFile self, DFF::Search * sctx, uint64_t start=0, uint64_t end=UINT64_MAX) -> int64_t
        rfind(VFile self, DFF::Search * sctx, uint64_t start=0) -> int64_t
        rfind(VFile self, DFF::Search * sctx) -> int64_t

        1
        """
        return _libvfs.VFile_rfind(self, *args)

    def count(self, *args):
        """
        count(VFile self, std::string needle, unsigned char wildcard='\0', int32_t maxcount=INT32_MAX, uint64_t start=0, 
            uint64_t end=UINT64_MAX) -> int32_t
        count(VFile self, std::string needle, unsigned char wildcard='\0', int32_t maxcount=INT32_MAX, uint64_t start=0) -> int32_t
        count(VFile self, std::string needle, unsigned char wildcard='\0', int32_t maxcount=INT32_MAX) -> int32_t
        count(VFile self, std::string needle, unsigned char wildcard='\0') -> int32_t
        count(VFile self, std::string needle) -> int32_t
        count(VFile self, DFF::Search * sctx, int32_t arg3=INT32_MAX, uint64_t start=0, uint64_t end=UINT64_MAX) -> int32_t
        count(VFile self, DFF::Search * sctx, int32_t arg3=INT32_MAX, uint64_t start=0) -> int32_t
        count(VFile self, DFF::Search * sctx, int32_t arg3=INT32_MAX) -> int32_t
        count(VFile self, DFF::Search * sctx) -> int32_t

        1
        """
        return _libvfs.VFile_count(self, *args)

    def indexes(self, *args):
        """
        indexes(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0, uint64_t end=UINT64_MAX) -> Vectui64
        indexes(VFile self, std::string needle, unsigned char wildcard='\0', uint64_t start=0) -> Vectui64
        indexes(VFile self, std::string needle, unsigned char wildcard='\0') -> Vectui64
        indexes(VFile self, std::string needle) -> Vectui64
        indexes(VFile self, DFF::Search * sctx, uint64_t start=0, uint64_t end=UINT64_MAX) -> Vectui64
        indexes(VFile self, DFF::Search * sctx, uint64_t start=0) -> Vectui64
        indexes(VFile self, DFF::Search * sctx) -> Vectui64

        1
        """
        return _libvfs.VFile_indexes(self, *args)

    def __iter__(self):
        return self

    def next(self):
        cpos = self.tell()
        idx = self.find('\n')
        if idx != -1:
           self.seek(cpos)
           buff = self.read(idx - cpos+1)
           if len(buff) == 0:
               raise StopIteration()
           else:
               return buff
        else:
           raise StopIteration()

VFile_swigregister = _libvfs.VFile_swigregister
VFile_swigregister(VFile)

class AttributesHandler(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributesHandler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributesHandler, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::AttributesHandler self, std::string handlerName) -> AttributesHandler

        1
        """
        if self.__class__ == AttributesHandler:
            _self = None
        else:
            _self = self
        this = _libvfs.new_AttributesHandler(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_AttributesHandler
    __del__ = lambda self : None;
    def attributes(self, *args):
        """
        attributes(AttributesHandler self, Node arg0) -> VMap

        1
        """
        return _libvfs.AttributesHandler_attributes(self, *args)

    def name(self):
        """
        name(AttributesHandler self) -> std::string

        1
        """
        return _libvfs.AttributesHandler_name(self)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_AttributesHandler(self)
        return weakref_proxy(self)
AttributesHandler_swigregister = _libvfs.AttributesHandler_swigregister
AttributesHandler_swigregister(AttributesHandler)

class AttributesHandlers(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributesHandlers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributesHandlers, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(DFF::AttributesHandlers self) -> AttributesHandlers

        1
        """
        this = _libvfs.new_AttributesHandlers()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_AttributesHandlers
    __del__ = lambda self : None;
    def count(self):
        """
        count(AttributesHandlers self) -> size_t

        1
        """
        return _libvfs.AttributesHandlers_count(self)

    def handlers(self):
        """
        handlers(AttributesHandlers self) -> std::set< DFF::AttributesHandler *,std::less< DFF::AttributesHandler * >,std::allocator< DFF::AttributesHandler * > > &

        1
        """
        return _libvfs.AttributesHandlers_handlers(self)

    def updateState(self):
        """
        updateState(AttributesHandlers self)

        1
        """
        return _libvfs.AttributesHandlers_updateState(self)

    def state(self):
        """
        state(AttributesHandlers self) -> uint64_t const

        1
        """
        return _libvfs.AttributesHandlers_state(self)

    def add(self, *args):
        """
        add(AttributesHandlers self, AttributesHandler attributeHandler) -> bool

        1
        """
        return _libvfs.AttributesHandlers_add(self, *args)

    def remove(self, *args):
        """
        remove(AttributesHandlers self, AttributesHandler attributeHandler) -> bool
        remove(AttributesHandlers self, std::string name) -> bool

        1
        """
        return _libvfs.AttributesHandlers_remove(self, *args)

AttributesHandlers_swigregister = _libvfs.AttributesHandlers_swigregister
AttributesHandlers_swigregister(AttributesHandlers)

ISFILE = _libvfs.ISFILE
ISDIR = _libvfs.ISDIR
ISLINK = _libvfs.ISLINK
ISDELETED = _libvfs.ISDELETED
ABSOLUTE_ATTR_NAME = _libvfs.ABSOLUTE_ATTR_NAME
RELATIVE_ATTR_NAME = _libvfs.RELATIVE_ATTR_NAME
class Node(_object):
    """
    This class is the base interface of every nodes reprensented in DFF virtual file
    system tree view. Most of the modules will have to extend this class before using
    it, that is why some of the methods are virtual.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Node, name)
    __repr__ = _swig_repr
    def _attributes(self):
        """
        _attributes(Node self) -> VMap

        1
        """
        return _libvfs.Node__attributes(self)

    def _attributesState(self):
        """
        _attributesState(Node self) -> uint64_t

        1
        """
        return _libvfs.Node__attributesState(self)

    def __init__(self, *args): 
        """
        __init__(DFF::Node self, std::string name, uint64_t size=0, Node parent=None, fso fsobj=None, bool registerNode=True) -> Node
        __init__(DFF::Node self, std::string name, uint64_t size=0, Node parent=None, fso fsobj=None) -> Node
        __init__(DFF::Node self, std::string name, uint64_t size=0, Node parent=None) -> Node
        __init__(DFF::Node self, std::string name, uint64_t size=0) -> Node
        __init__(DFF::Node self, std::string name) -> Node
        __init__(DFF::Node self) -> Node

        1
        """
        if self.__class__ == Node:
            _self = None
        else:
            _self = self
        this = _libvfs.new_Node(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_Node
    __del__ = lambda self : None;
    __swig_setmethods__["__at"] = _libvfs.Node___at_set
    __swig_getmethods__["__at"] = _libvfs.Node___at_get
    if _newclass:__at = _swig_property(_libvfs.Node___at_get, _libvfs.Node___at_set)
    def setFile(self):
        """
        setFile(Node self)

        If the node is a file this method should be called to set proper attributes.

        """
        return _libvfs.Node_setFile(self)

    def setDir(self):
        """
        setDir(Node self)

        If the node is a directory this method should be called to set proper attributes.

        """
        return _libvfs.Node_setDir(self)

    def setLink(self):
        """
        setLink(Node self)

        If the node is a link this method should be called to set proper attributes.

        """
        return _libvfs.Node_setLink(self)

    def setDeleted(self):
        """
        setDeleted(Node self)

        If the node corresponds to a data which was deleted (and recovered by the
        module), this method should be called to set proper attributes.

        """
        return _libvfs.Node_setDeleted(self)

    def setSize(self, *args):
        """
        setSize(Node self, uint64_t size)

        Set the node size in bytes.

        """
        return _libvfs.Node_setSize(self, *args)

    def setFsobj(self, *args):
        """
        setFsobj(Node self, fso obj)

        Set a fso object.

        """
        return _libvfs.Node_setFsobj(self, *args)

    def setParent(self, *args):
        """
        setParent(Node self, Node parent)

        Set the parent's node of the current node.

        """
        return _libvfs.Node_setParent(self, *args)

    def fileMapping(self, *args):
        """
        fileMapping(Node self, FileMapping arg0)

        The fileMapping method takes a pointer to an instance of a FileMapping object
        as parameter. This method is called when a node is opened.

        The fileMapping method must "filled up" the FileMapping object which was passed
        to it by creating chunks of the files. A chunk is a structure containing 2
        important informations :
         * The size (in bytes) of the chunk
         * Its address on the vfile.

        In human speakable langugage it means that the FileMapping structure contains
        a list of data structure, each of them giving a part of the file content position
        on the vfile.

        FileMapping can be filled up by calling their push() method.

        """
        return _libvfs.Node_fileMapping(self, *args)

    def fileMappingState(self):
        """
        fileMappingState(Node self) -> uint64_t

        1
        """
        return _libvfs.Node_fileMappingState(self)

    def size(self):
        """
        size(Node self) -> uint64_t

        Return the size of the node

        """
        return _libvfs.Node_size(self)

    def path(self):
        """
        path(Node self) -> std::string

        return the path to the node

        """
        return _libvfs.Node_path(self)

    def name(self):
        """
        name(Node self) -> std::string

        return the name of the node

        """
        return _libvfs.Node_name(self)

    def absolute(self):
        """
        absolute(Node self) -> std::string

        return the absolute path of the node (equivalent to Node::path() + Node::name())

        """
        return _libvfs.Node_absolute(self)

    def extension(self):
        """
        extension(Node self) -> std::string

        1
        """
        return _libvfs.Node_extension(self)

    def isFile(self):
        """
        isFile(Node self) -> bool

        return true if the node is a file, false otherwise

        """
        return _libvfs.Node_isFile(self)

    def isDir(self):
        """
        isDir(Node self) -> bool

        return true if the node is a directory, false otherwise

        """
        return _libvfs.Node_isDir(self)

    def isLink(self):
        """
        isLink(Node self) -> bool

        return true if the node is a link, false otherwise

        """
        return _libvfs.Node_isLink(self)

    def isVDir(self):
        """
        isVDir(Node self) -> bool

        return true if the node is a link to a directory, false otherwise

        """
        return _libvfs.Node_isVDir(self)

    def isDeleted(self):
        """
        isDeleted(Node self) -> bool

        return true if the node is deleted, false otherwise

        """
        return _libvfs.Node_isDeleted(self)

    def fsobj(self):
        """
        fsobj(Node self) -> fso

        return a pointer to fso instance associated with the node

        """
        return _libvfs.Node_fsobj(self)

    def parent(self):
        """
        parent(Node self) -> Node

        return a pointer to the node which is the parent of the cuurent node.

        """
        return _libvfs.Node_parent(self)

    def children(self):
        """
        children(Node self) -> VecNode

        return a vector containing pointers to the children of the current node. If the
        node has no child, the vector is empty.

        """
        return _libvfs.Node_children(self)

    def addChild(self, *args):
        """
        addChild(Node self, Node child) -> bool

        Take a pointer to a node in parameter. This node will be added to the current node
        as one of its child.

        """
        return _libvfs.Node_addChild(self, *args)

    def removeChild(self, *args):
        """
        removeChild(Node self, Node child) -> bool

        1
        """
        return _libvfs.Node_removeChild(self, *args)

    def hasChildren(self):
        """
        hasChildren(Node self) -> bool

        return true if the node has one or more children, false otherwise

        """
        return _libvfs.Node_hasChildren(self)

    def childCount(self):
        """
        childCount(Node self) -> uint32_t

        return the number of children the node has

        """
        return _libvfs.Node_childCount(self)

    def totalChildrenCount(self, *args):
        """
        totalChildrenCount(Node self, uint32_t depth=(uint32_t) -1) -> uint64_t
        totalChildrenCount(Node self) -> uint64_t

        1
        """
        return _libvfs.Node_totalChildrenCount(self, *args)

    def open(self):
        """
        open(Node self) -> VFile

        Open the node and return a pointer to a VFile instance

        """
        return _libvfs.Node_open(self)

    def at(self):
        """
        at(Node self) -> uint32_t

        1
        """
        return _libvfs.Node_at(self)

    def uid(self):
        """
        uid(Node self) -> uint64_t

        1
        """
        return _libvfs.Node_uid(self)

    def attributesHandlers(self):
        """
        attributesHandlers(Node self) -> AttributesHandlers

        1
        """
        return _libvfs.Node_attributesHandlers(self)

    def registerAttributes(self, *args):
        """
        registerAttributes(Node self, AttributesHandler arg0) -> bool

        1
        """
        return _libvfs.Node_registerAttributes(self, *args)

    def dataType(self):
        """
        dataType(Node self) -> std::string const

        1
        """
        return _libvfs.Node_dataType(self)

    def attributes(self):
        """
        attributes(Node self) -> VMap

        1
        """
        return _libvfs.Node_attributes(self)

    def attributesByType(self, *args):
        """
        attributesByType(Node self, uint8_t type) -> VMap

        1
        """
        return _libvfs.Node_attributesByType(self, *args)

    def attributesByName(self, *args):
        """
        attributesByName(Node self, std::string name, DFF::attributeNameType tname=RELATIVE_ATTR_NAME) -> VList
        attributesByName(Node self, std::string name) -> VList

        1
        """
        return _libvfs.Node_attributesByName(self, *args)

    def attributesNames(self, *args):
        """
        attributesNames(Node self, DFF::attributeNameType tname=RELATIVE_ATTR_NAME) -> ListString
        attributesNames(Node self) -> ListString

        1
        """
        return _libvfs.Node_attributesNames(self, *args)

    def attributesNamesAndTypes(self):
        """
        attributesNamesAndTypes(Node self) -> MapNameTypes

        1
        """
        return _libvfs.Node_attributesNamesAndTypes(self)

    def icon(self):
        """
        icon(Node self) -> std::string

        1
        """
        return _libvfs.Node_icon(self)

    def compatibleModules(self):
        """
        compatibleModules(Node self) -> ListString

        1
        """
        return _libvfs.Node_compatibleModules(self)

    def dynamicAttributes(self, *args):
        """
        dynamicAttributes(Node self) -> VMap
        dynamicAttributes(Node self, std::string name) -> VMap

        1
        """
        return _libvfs.Node_dynamicAttributes(self, *args)

    def dynamicAttributesNames(self):
        """
        dynamicAttributesNames(Node self) -> ListString

        1
        """
        return _libvfs.Node_dynamicAttributesNames(self)

    def fsoAttributes(self):
        """
        fsoAttributes(Node self) -> VMap

        1
        """
        return _libvfs.Node_fsoAttributes(self)

    def setTag(self, *args):
        """
        setTag(Node self, std::string name) -> bool
        setTag(Node self, uint32_t id) -> bool

        1
        """
        return _libvfs.Node_setTag(self, *args)

    def removeTag(self, *args):
        """
        removeTag(Node self, std::string name) -> bool
        removeTag(Node self, uint32_t id) -> bool

        1
        """
        return _libvfs.Node_removeTag(self, *args)

    def isTagged(self, *args):
        """
        isTagged(Node self, std::string name) -> bool
        isTagged(Node self, uint32_t id) -> bool

        1
        """
        return _libvfs.Node_isTagged(self, *args)

    def tags(self):
        """
        tags(Node self) -> TagVect

        1
        """
        return _libvfs.Node_tags(self)

    def tagsId(self):
        """
        tagsId(Node self) -> Vectui32

        1
        """
        return _libvfs.Node_tagsId(self)

    def __iter__(self):
      for node in self.next:  
         yield node

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_Node(self)
        return weakref_proxy(self)
Node_swigregister = _libvfs.Node_swigregister
Node_swigregister(Node)

class VFSRootNode(Node):
    """1"""
    __swig_setmethods__ = {}
    for _s in [Node]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VFSRootNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VFSRootNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::VFSRootNode self, std::string name) -> VFSRootNode

        1
        """
        this = _libvfs.new_VFSRootNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_VFSRootNode
    __del__ = lambda self : None;
VFSRootNode_swigregister = _libvfs.VFSRootNode_swigregister
VFSRootNode_swigregister(VFSRootNode)

class ModulesRootNode(Node,dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [Node,dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModulesRootNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Node,dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModulesRootNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::ModulesRootNode self, EventHandler vfs, Node root) -> ModulesRootNode

        1
        """
        this = _libvfs.new_ModulesRootNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_ModulesRootNode
    __del__ = lambda self : None;
    def icon(self):
        """
        icon(ModulesRootNode self) -> std::string

        1
        """
        return _libvfs.ModulesRootNode_icon(self)

    def Event(self, *args):
        """
        Event(ModulesRootNode self, event e)

        1
        """
        return _libvfs.ModulesRootNode_Event(self, *args)

ModulesRootNode_swigregister = _libvfs.ModulesRootNode_swigregister
ModulesRootNode_swigregister(ModulesRootNode)

class VLink(Node):
    """
    The class VLink inherits the Node class. It a specific type of Node corresponding
    to a link to an other node. This class can be useful to create nodes "pointing"
    on other nodes, such as Linux symbolic links or Windows short-cuts for example.

    Otherwise, the VLink class is pretty similar to the Node class.

    """
    __swig_setmethods__ = {}
    for _s in [Node]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VLink, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VLink, name)
    __repr__ = _swig_repr
    def fileMapping(self, *args):
        """
        fileMapping(VLink self, FileMapping arg0)

        The fileMapping method takes a pointer to an instance of a FileMapping object
        as parameter. This method is called when a node is opened.

        The fileMapping method must "filled up" the FileMapping object which was passed
        to it by creating chunks of the files. A chunk is a structure containing 2
        important informations :
         * The size (in bytes) of the chunk
         * Its address on the vfile.

        In human speakable langugage it means that the FileMapping structure contains
        a list of data structure, each of them giving a part of the file content position
        on the vfile.

        FileMapping can be filled up by calling their push() method.

        """
        return _libvfs.VLink_fileMapping(self, *args)

    def size(self):
        """
        size(VLink self) -> uint64_t

        Return the size of the node

        """
        return _libvfs.VLink_size(self)

    def linkPath(self):
        """
        linkPath(VLink self) -> std::string

        Return the path to the pointed node.

        """
        return _libvfs.VLink_linkPath(self)

    def linkName(self):
        """
        linkName(VLink self) -> std::string

        Return the name of the pointed node.

        """
        return _libvfs.VLink_linkName(self)

    def linkAbsolute(self):
        """
        linkAbsolute(VLink self) -> std::string

        1
        """
        return _libvfs.VLink_linkAbsolute(self)

    def isFile(self):
        """
        isFile(VLink self) -> bool

        return true if the node is a file, false otherwise

        """
        return _libvfs.VLink_isFile(self)

    def isDir(self):
        """
        isDir(VLink self) -> bool

        return true if the node is a directory, false otherwise

        """
        return _libvfs.VLink_isDir(self)

    def isLink(self):
        """
        isLink(VLink self) -> bool

        return true if the node is a link, false otherwise

        """
        return _libvfs.VLink_isLink(self)

    def isVDir(self):
        """
        isVDir(VLink self) -> bool

        return true if the node is a link to a directory, false otherwise

        """
        return _libvfs.VLink_isVDir(self)

    def isDeleted(self):
        """
        isDeleted(VLink self) -> bool

        return true if the node is deleted, false otherwise

        """
        return _libvfs.VLink_isDeleted(self)

    def fsobj(self):
        """
        fsobj(VLink self) -> fso

        return a pointer to fso instance associated with the node

        """
        return _libvfs.VLink_fsobj(self)

    def open(self):
        """
        open(VLink self) -> VFile

        1
        """
        return _libvfs.VLink_open(self)

    def __init__(self, *args): 
        """
        __init__(DFF::VLink self, Node linkedNode, Node parent, std::string newname="") -> VLink
        __init__(DFF::VLink self, Node linkedNode, Node parent) -> VLink

        1
        """
        if self.__class__ == VLink:
            _self = None
        else:
            _self = self
        this = _libvfs.new_VLink(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_VLink
    __del__ = lambda self : None;
    def linkParent(self):
        """
        linkParent(VLink self) -> Node

        Return a pointer to the parent node of the pointed node.

        """
        return _libvfs.VLink_linkParent(self)

    def linkChildren(self):
        """
        linkChildren(VLink self) -> VecNode

        Return the list of children of the pointed node.

        """
        return _libvfs.VLink_linkChildren(self)

    def linkHasChildren(self):
        """
        linkHasChildren(VLink self) -> bool

        Return `true` if the pointed node has children, `false` otherwise.

        """
        return _libvfs.VLink_linkHasChildren(self)

    def linkChildCount(self):
        """
        linkChildCount(VLink self) -> uint32_t

        Return the number of child the pointed nodes has.

        """
        return _libvfs.VLink_linkChildCount(self)

    def linkNode(self):
        """
        linkNode(VLink self) -> Node

        Return a pointer to the node pointed by the link.

        """
        return _libvfs.VLink_linkNode(self)

    def attributesHandlers(self):
        """
        attributesHandlers(VLink self) -> AttributesHandlers

        1
        """
        return _libvfs.VLink_attributesHandlers(self)

    def registerAttributes(self, *args):
        """
        registerAttributes(VLink self, AttributesHandler arg0) -> bool

        1
        """
        return _libvfs.VLink_registerAttributes(self, *args)

    def dataType(self):
        """
        dataType(VLink self) -> std::string const

        1
        """
        return _libvfs.VLink_dataType(self)

    def attributes(self):
        """
        attributes(VLink self) -> VMap

        1
        """
        return _libvfs.VLink_attributes(self)

    def attributesByType(self, *args):
        """
        attributesByType(VLink self, uint8_t type) -> VMap

        1
        """
        return _libvfs.VLink_attributesByType(self, *args)

    def attributesByName(self, *args):
        """
        attributesByName(VLink self, std::string name, DFF::attributeNameType tname=RELATIVE_ATTR_NAME) -> VList
        attributesByName(VLink self, std::string name) -> VList

        1
        """
        return _libvfs.VLink_attributesByName(self, *args)

    def attributesNames(self, *args):
        """
        attributesNames(VLink self, DFF::attributeNameType tname=RELATIVE_ATTR_NAME) -> ListString
        attributesNames(VLink self) -> ListString

        1
        """
        return _libvfs.VLink_attributesNames(self, *args)

    def attributesNamesAndTypes(self):
        """
        attributesNamesAndTypes(VLink self) -> MapNameTypes

        1
        """
        return _libvfs.VLink_attributesNamesAndTypes(self)

    def dynamicAttributes(self, *args):
        """
        dynamicAttributes(VLink self) -> VMap
        dynamicAttributes(VLink self, std::string name) -> VMap

        1
        """
        return _libvfs.VLink_dynamicAttributes(self, *args)

    def dynamicAttributesNames(self):
        """
        dynamicAttributesNames(VLink self) -> ListString

        1
        """
        return _libvfs.VLink_dynamicAttributesNames(self)

    def fsoAttributes(self):
        """
        fsoAttributes(VLink self) -> VMap

        1
        """
        return _libvfs.VLink_fsoAttributes(self)

    def icon(self):
        """
        icon(VLink self) -> std::string

        1
        """
        return _libvfs.VLink_icon(self)

    def compatibleModules(self):
        """
        compatibleModules(VLink self) -> ListString

        1
        """
        return _libvfs.VLink_compatibleModules(self)

    def setTag(self, *args):
        """
        setTag(VLink self, std::string name) -> bool
        setTag(VLink self, uint32_t id) -> bool

        1
        """
        return _libvfs.VLink_setTag(self, *args)

    def removeTag(self, *args):
        """
        removeTag(VLink self, std::string name) -> bool
        removeTag(VLink self, uint32_t id) -> bool

        1
        """
        return _libvfs.VLink_removeTag(self, *args)

    def isTagged(self, *args):
        """
        isTagged(VLink self, std::string name) -> bool
        isTagged(VLink self, uint32_t id) -> bool

        1
        """
        return _libvfs.VLink_isTagged(self, *args)

    def tags(self):
        """
        tags(VLink self) -> TagVect

        1
        """
        return _libvfs.VLink_tags(self)

    def tagsId(self):
        """
        tagsId(VLink self) -> Vectui32

        1
        """
        return _libvfs.VLink_tagsId(self)

    def __disown__(self):
        self.this.disown()
        _libvfs.disown_VLink(self)
        return weakref_proxy(self)
    def _attributes(self):
        """
        _attributes(VLink self) -> VMap

        1
        """
        return _libvfs.VLink__attributes(self)

    def _attributesState(self):
        """
        _attributesState(VLink self) -> uint64_t

        1
        """
        return _libvfs.VLink__attributesState(self)

VLink_swigregister = _libvfs.VLink_swigregister
VLink_swigregister(VLink)

class fdinfo(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fdinfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fdinfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["node"] = _libvfs.fdinfo_node_set
    __swig_getmethods__["node"] = _libvfs.fdinfo_node_get
    if _newclass:node = _swig_property(_libvfs.fdinfo_node_get, _libvfs.fdinfo_node_set)
    __swig_setmethods__["id"] = _libvfs.fdinfo_id_set
    __swig_getmethods__["id"] = _libvfs.fdinfo_id_get
    if _newclass:id = _swig_property(_libvfs.fdinfo_id_get, _libvfs.fdinfo_id_set)
    __swig_setmethods__["offset"] = _libvfs.fdinfo_offset_set
    __swig_getmethods__["offset"] = _libvfs.fdinfo_offset_get
    if _newclass:offset = _swig_property(_libvfs.fdinfo_offset_get, _libvfs.fdinfo_offset_set)
    __swig_setmethods__["file"] = _libvfs.fdinfo_file_set
    __swig_getmethods__["file"] = _libvfs.fdinfo_file_get
    if _newclass:file = _swig_property(_libvfs.fdinfo_file_get, _libvfs.fdinfo_file_set)
    def __init__(self): 
        """
        __init__(DFF::fdinfo self) -> fdinfo

        1
        """
        this = _libvfs.new_fdinfo()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_fdinfo
    __del__ = lambda self : None;
fdinfo_swigregister = _libvfs.fdinfo_swigregister
fdinfo_swigregister(fdinfo)

class FdManager(_object):
    """
    The FdManager is used to manage all open file descriptors.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FdManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FdManager, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(DFF::FdManager self) -> FdManager

        1
        """
        this = _libvfs.new_FdManager()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libvfs.delete_FdManager
    __del__ = lambda self : None;
    def get(self, *args):
        """
        get(FdManager self, int32_t fd) -> fdinfo

        Return a pointer to the fdinfo structure correponding to file descriptor `fd`

        Params :
                * fd : the file decsriptor on which you want to get the fdinfo structure

        """
        return _libvfs.FdManager_get(self, *args)

    def remove(self, *args):
        """
        remove(FdManager self, int32_t fd)

        Free the resources occupied by the fdinfo structure correponding to `fd`

        """
        return _libvfs.FdManager_remove(self, *args)

    def push(self, *args):
        """
        push(FdManager self, fdinfo fi) -> int32_t

        Push the fdinfo `fi` into the list of opened file descriptors.

        """
        return _libvfs.FdManager_push(self, *args)

FdManager_swigregister = _libvfs.FdManager_swigregister
FdManager_swigregister(FdManager)

class VecNode(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VecNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VecNode, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(VecNode self) -> SwigPyIterator

        1
        """
        return _libvfs.VecNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(VecNode self) -> bool

        1
        """
        return _libvfs.VecNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(VecNode self) -> bool

        1
        """
        return _libvfs.VecNode___bool__(self)

    def __len__(self):
        """
        __len__(VecNode self) -> std::vector< DFF::Node * >::size_type

        1
        """
        return _libvfs.VecNode___len__(self)

    def pop(self):
        """
        pop(VecNode self) -> Node

        1
        """
        return _libvfs.VecNode_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(VecNode self, std::vector< DFF::Node * >::difference_type i, std::vector< DFF::Node * >::difference_type j) -> VecNode

        1
        """
        return _libvfs.VecNode___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(VecNode self, std::vector< DFF::Node * >::difference_type i, std::vector< DFF::Node * >::difference_type j, 
            VecNode v=std::vector< DFF::Node *,std::allocator< DFF::Node * > >())
        __setslice__(VecNode self, std::vector< DFF::Node * >::difference_type i, std::vector< DFF::Node * >::difference_type j)

        1
        """
        return _libvfs.VecNode___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(VecNode self, std::vector< DFF::Node * >::difference_type i, std::vector< DFF::Node * >::difference_type j)

        1
        """
        return _libvfs.VecNode___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(VecNode self, std::vector< DFF::Node * >::difference_type i)
        __delitem__(VecNode self, PySliceObject * slice)

        1
        """
        return _libvfs.VecNode___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(VecNode self, PySliceObject * slice) -> VecNode
        __getitem__(VecNode self, std::vector< DFF::Node * >::difference_type i) -> Node

        1
        """
        return _libvfs.VecNode___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(VecNode self, PySliceObject * slice, VecNode v)
        __setitem__(VecNode self, PySliceObject * slice)
        __setitem__(VecNode self, std::vector< DFF::Node * >::difference_type i, Node x)

        1
        """
        return _libvfs.VecNode___setitem__(self, *args)

    def append(self, *args):
        """
        append(VecNode self, Node x)

        1
        """
        return _libvfs.VecNode_append(self, *args)

    def empty(self):
        """
        empty(VecNode self) -> bool

        1
        """
        return _libvfs.VecNode_empty(self)

    def size(self):
        """
        size(VecNode self) -> std::vector< DFF::Node * >::size_type

        1
        """
        return _libvfs.VecNode_size(self)

    def clear(self):
        """
        clear(VecNode self)

        1
        """
        return _libvfs.VecNode_clear(self)

    def swap(self, *args):
        """
        swap(VecNode self, VecNode v)

        1
        """
        return _libvfs.VecNode_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(VecNode self) -> std::vector< DFF::Node * >::allocator_type

        1
        """
        return _libvfs.VecNode_get_allocator(self)

    def begin(self):
        """
        begin(VecNode self) -> std::vector< DFF::Node * >::iterator

        1
        """
        return _libvfs.VecNode_begin(self)

    def end(self):
        """
        end(VecNode self) -> std::vector< DFF::Node * >::iterator

        1
        """
        return _libvfs.VecNode_end(self)

    def rbegin(self):
        """
        rbegin(VecNode self) -> std::vector< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.VecNode_rbegin(self)

    def rend(self):
        """
        rend(VecNode self) -> std::vector< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.VecNode_rend(self)

    def pop_back(self):
        """
        pop_back(VecNode self)

        1
        """
        return _libvfs.VecNode_pop_back(self)

    def erase(self, *args):
        """
        erase(VecNode self, std::vector< DFF::Node * >::iterator pos) -> std::vector< DFF::Node * >::iterator
        erase(VecNode self, std::vector< DFF::Node * >::iterator first, std::vector< DFF::Node * >::iterator last) -> std::vector< DFF::Node * >::iterator

        1
        """
        return _libvfs.VecNode_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.DFF::Node)> self) -> VecNode
        __init__(std::vector<(p.DFF::Node)> self, VecNode arg2) -> VecNode
        __init__(std::vector<(p.DFF::Node)> self, std::vector< DFF::Node * >::size_type size) -> VecNode
        __init__(std::vector<(p.DFF::Node)> self, std::vector< DFF::Node * >::size_type size, Node value) -> VecNode

        1
        """
        this = _libvfs.new_VecNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(VecNode self, Node x)

        1
        """
        return _libvfs.VecNode_push_back(self, *args)

    def front(self):
        """
        front(VecNode self) -> Node

        1
        """
        return _libvfs.VecNode_front(self)

    def back(self):
        """
        back(VecNode self) -> Node

        1
        """
        return _libvfs.VecNode_back(self)

    def assign(self, *args):
        """
        assign(VecNode self, std::vector< DFF::Node * >::size_type n, Node x)

        1
        """
        return _libvfs.VecNode_assign(self, *args)

    def resize(self, *args):
        """
        resize(VecNode self, std::vector< DFF::Node * >::size_type new_size)
        resize(VecNode self, std::vector< DFF::Node * >::size_type new_size, Node x)

        1
        """
        return _libvfs.VecNode_resize(self, *args)

    def insert(self, *args):
        """
        insert(VecNode self, std::vector< DFF::Node * >::iterator pos, Node x) -> std::vector< DFF::Node * >::iterator
        insert(VecNode self, std::vector< DFF::Node * >::iterator pos, std::vector< DFF::Node * >::size_type n, 
            Node x)

        1
        """
        return _libvfs.VecNode_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(VecNode self, std::vector< DFF::Node * >::size_type n)

        1
        """
        return _libvfs.VecNode_reserve(self, *args)

    def capacity(self):
        """
        capacity(VecNode self) -> std::vector< DFF::Node * >::size_type

        1
        """
        return _libvfs.VecNode_capacity(self)

    __swig_destroy__ = _libvfs.delete_VecNode
    __del__ = lambda self : None;
VecNode_swigregister = _libvfs.VecNode_swigregister
VecNode_swigregister(VecNode)

class ListNode(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListNode, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(ListNode self) -> SwigPyIterator

        1
        """
        return _libvfs.ListNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(ListNode self) -> bool

        1
        """
        return _libvfs.ListNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(ListNode self) -> bool

        1
        """
        return _libvfs.ListNode___bool__(self)

    def __len__(self):
        """
        __len__(ListNode self) -> std::list< DFF::Node * >::size_type

        1
        """
        return _libvfs.ListNode___len__(self)

    def pop(self):
        """
        pop(ListNode self) -> Node

        1
        """
        return _libvfs.ListNode_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(ListNode self, std::list< DFF::Node * >::difference_type i, std::list< DFF::Node * >::difference_type j) -> ListNode

        1
        """
        return _libvfs.ListNode___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(ListNode self, std::list< DFF::Node * >::difference_type i, std::list< DFF::Node * >::difference_type j, 
            ListNode v=std::list< DFF::Node *,std::allocator< DFF::Node * > >())
        __setslice__(ListNode self, std::list< DFF::Node * >::difference_type i, std::list< DFF::Node * >::difference_type j)

        1
        """
        return _libvfs.ListNode___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(ListNode self, std::list< DFF::Node * >::difference_type i, std::list< DFF::Node * >::difference_type j)

        1
        """
        return _libvfs.ListNode___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(ListNode self, std::list< DFF::Node * >::difference_type i)
        __delitem__(ListNode self, PySliceObject * slice)

        1
        """
        return _libvfs.ListNode___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(ListNode self, PySliceObject * slice) -> ListNode
        __getitem__(ListNode self, std::list< DFF::Node * >::difference_type i) -> Node

        1
        """
        return _libvfs.ListNode___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(ListNode self, PySliceObject * slice, ListNode v)
        __setitem__(ListNode self, PySliceObject * slice)
        __setitem__(ListNode self, std::list< DFF::Node * >::difference_type i, Node x)

        1
        """
        return _libvfs.ListNode___setitem__(self, *args)

    def append(self, *args):
        """
        append(ListNode self, Node x)

        1
        """
        return _libvfs.ListNode_append(self, *args)

    def empty(self):
        """
        empty(ListNode self) -> bool

        1
        """
        return _libvfs.ListNode_empty(self)

    def size(self):
        """
        size(ListNode self) -> std::list< DFF::Node * >::size_type

        1
        """
        return _libvfs.ListNode_size(self)

    def clear(self):
        """
        clear(ListNode self)

        1
        """
        return _libvfs.ListNode_clear(self)

    def swap(self, *args):
        """
        swap(ListNode self, ListNode v)

        1
        """
        return _libvfs.ListNode_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(ListNode self) -> std::list< DFF::Node * >::allocator_type

        1
        """
        return _libvfs.ListNode_get_allocator(self)

    def begin(self):
        """
        begin(ListNode self) -> std::list< DFF::Node * >::iterator

        1
        """
        return _libvfs.ListNode_begin(self)

    def end(self):
        """
        end(ListNode self) -> std::list< DFF::Node * >::iterator

        1
        """
        return _libvfs.ListNode_end(self)

    def rbegin(self):
        """
        rbegin(ListNode self) -> std::list< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.ListNode_rbegin(self)

    def rend(self):
        """
        rend(ListNode self) -> std::list< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.ListNode_rend(self)

    def pop_back(self):
        """
        pop_back(ListNode self)

        1
        """
        return _libvfs.ListNode_pop_back(self)

    def erase(self, *args):
        """
        erase(ListNode self, std::list< DFF::Node * >::iterator pos) -> std::list< DFF::Node * >::iterator
        erase(ListNode self, std::list< DFF::Node * >::iterator first, std::list< DFF::Node * >::iterator last) -> std::list< DFF::Node * >::iterator

        1
        """
        return _libvfs.ListNode_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(p.DFF::Node)> self) -> ListNode
        __init__(std::list<(p.DFF::Node)> self, ListNode arg2) -> ListNode
        __init__(std::list<(p.DFF::Node)> self, std::list< DFF::Node * >::size_type size) -> ListNode
        __init__(std::list<(p.DFF::Node)> self, std::list< DFF::Node * >::size_type size, Node value) -> ListNode

        1
        """
        this = _libvfs.new_ListNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(ListNode self, Node x)

        1
        """
        return _libvfs.ListNode_push_back(self, *args)

    def front(self):
        """
        front(ListNode self) -> Node

        1
        """
        return _libvfs.ListNode_front(self)

    def back(self):
        """
        back(ListNode self) -> Node

        1
        """
        return _libvfs.ListNode_back(self)

    def assign(self, *args):
        """
        assign(ListNode self, std::list< DFF::Node * >::size_type n, Node x)

        1
        """
        return _libvfs.ListNode_assign(self, *args)

    def resize(self, *args):
        """
        resize(ListNode self, std::list< DFF::Node * >::size_type new_size)
        resize(ListNode self, std::list< DFF::Node * >::size_type new_size, Node x)

        1
        """
        return _libvfs.ListNode_resize(self, *args)

    def insert(self, *args):
        """
        insert(ListNode self, std::list< DFF::Node * >::iterator pos, Node x) -> std::list< DFF::Node * >::iterator
        insert(ListNode self, std::list< DFF::Node * >::iterator pos, std::list< DFF::Node * >::size_type n, Node x)

        1
        """
        return _libvfs.ListNode_insert(self, *args)

    def pop_front(self):
        """
        pop_front(ListNode self)

        1
        """
        return _libvfs.ListNode_pop_front(self)

    def push_front(self, *args):
        """
        push_front(ListNode self, Node x)

        1
        """
        return _libvfs.ListNode_push_front(self, *args)

    def remove(self, *args):
        """
        remove(ListNode self, Node x)

        1
        """
        return _libvfs.ListNode_remove(self, *args)

    def unique(self):
        """
        unique(ListNode self)

        1
        """
        return _libvfs.ListNode_unique(self)

    def reverse(self):
        """
        reverse(ListNode self)

        1
        """
        return _libvfs.ListNode_reverse(self)

    def sort(self):
        """
        sort(ListNode self)

        1
        """
        return _libvfs.ListNode_sort(self)

    def merge(self, *args):
        """
        merge(ListNode self, ListNode x)

        1
        """
        return _libvfs.ListNode_merge(self, *args)

    __swig_destroy__ = _libvfs.delete_ListNode
    __del__ = lambda self : None;
ListNode_swigregister = _libvfs.ListNode_swigregister
ListNode_swigregister(ListNode)

class SetNode(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SetNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SetNode, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(SetNode self) -> SwigPyIterator

        1
        """
        return _libvfs.SetNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(SetNode self) -> bool

        1
        """
        return _libvfs.SetNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(SetNode self) -> bool

        1
        """
        return _libvfs.SetNode___bool__(self)

    def __len__(self):
        """
        __len__(SetNode self) -> std::set< DFF::Node * >::size_type

        1
        """
        return _libvfs.SetNode___len__(self)

    def append(self, *args):
        """
        append(SetNode self, Node x)

        1
        """
        return _libvfs.SetNode_append(self, *args)

    def __contains__(self, *args):
        """
        __contains__(SetNode self, Node x) -> bool

        1
        """
        return _libvfs.SetNode___contains__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(SetNode self, std::set< DFF::Node * >::difference_type i) -> Node

        1
        """
        return _libvfs.SetNode___getitem__(self, *args)

    def add(self, *args):
        """
        add(SetNode self, Node x)

        1
        """
        return _libvfs.SetNode_add(self, *args)

    def discard(self, *args):
        """
        discard(SetNode self, Node x)

        1
        """
        return _libvfs.SetNode_discard(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::set<(p.DFF::Node)> self, std::less< DFF::Node * > const & arg2) -> SetNode
        __init__(std::set<(p.DFF::Node)> self) -> SetNode
        __init__(std::set<(p.DFF::Node)> self, SetNode arg2) -> SetNode

        1
        """
        this = _libvfs.new_SetNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(SetNode self) -> bool

        1
        """
        return _libvfs.SetNode_empty(self)

    def size(self):
        """
        size(SetNode self) -> std::set< DFF::Node * >::size_type

        1
        """
        return _libvfs.SetNode_size(self)

    def clear(self):
        """
        clear(SetNode self)

        1
        """
        return _libvfs.SetNode_clear(self)

    def swap(self, *args):
        """
        swap(SetNode self, SetNode v)

        1
        """
        return _libvfs.SetNode_swap(self, *args)

    def count(self, *args):
        """
        count(SetNode self, Node x) -> std::set< DFF::Node * >::size_type

        1
        """
        return _libvfs.SetNode_count(self, *args)

    def begin(self):
        """
        begin(SetNode self) -> std::set< DFF::Node * >::iterator

        1
        """
        return _libvfs.SetNode_begin(self)

    def end(self):
        """
        end(SetNode self) -> std::set< DFF::Node * >::iterator

        1
        """
        return _libvfs.SetNode_end(self)

    def rbegin(self):
        """
        rbegin(SetNode self) -> std::set< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.SetNode_rbegin(self)

    def rend(self):
        """
        rend(SetNode self) -> std::set< DFF::Node * >::reverse_iterator

        1
        """
        return _libvfs.SetNode_rend(self)

    def erase(self, *args):
        """
        erase(SetNode self, Node x) -> std::set< DFF::Node * >::size_type
        erase(SetNode self, std::set< DFF::Node * >::iterator pos)
        erase(SetNode self, std::set< DFF::Node * >::iterator first, std::set< DFF::Node * >::iterator last)

        1
        """
        return _libvfs.SetNode_erase(self, *args)

    def find(self, *args):
        """
        find(SetNode self, Node x) -> std::set< DFF::Node * >::iterator

        1
        """
        return _libvfs.SetNode_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(SetNode self, Node x) -> std::set< DFF::Node * >::iterator

        1
        """
        return _libvfs.SetNode_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(SetNode self, Node x) -> std::set< DFF::Node * >::iterator

        1
        """
        return _libvfs.SetNode_upper_bound(self, *args)

    def equal_range(self, *args):
        """
        equal_range(SetNode self, Node x) -> std::pair< std::set< DFF::Node * >::iterator,std::set< DFF::Node * >::iterator >

        1
        """
        return _libvfs.SetNode_equal_range(self, *args)

    def insert(self, *args):
        """
        insert(SetNode self, Node __x) -> std::pair< std::set< DFF::Node * >::iterator,bool >

        1
        """
        return _libvfs.SetNode_insert(self, *args)

    __swig_destroy__ = _libvfs.delete_SetNode
    __del__ = lambda self : None;
SetNode_swigregister = _libvfs.SetNode_swigregister
SetNode_swigregister(SetNode)

class VectChunk(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectChunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectChunk, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(VectChunk self) -> SwigPyIterator

        1
        """
        return _libvfs.VectChunk_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(VectChunk self) -> bool

        1
        """
        return _libvfs.VectChunk___nonzero__(self)

    def __bool__(self):
        """
        __bool__(VectChunk self) -> bool

        1
        """
        return _libvfs.VectChunk___bool__(self)

    def __len__(self):
        """
        __len__(VectChunk self) -> std::vector< DFF::chunk * >::size_type

        1
        """
        return _libvfs.VectChunk___len__(self)

    def pop(self):
        """
        pop(VectChunk self) -> chunk

        1
        """
        return _libvfs.VectChunk_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(VectChunk self, std::vector< DFF::chunk * >::difference_type i, std::vector< DFF::chunk * >::difference_type j) -> VectChunk

        1
        """
        return _libvfs.VectChunk___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(VectChunk self, std::vector< DFF::chunk * >::difference_type i, std::vector< DFF::chunk * >::difference_type j, 
            VectChunk v=std::vector< DFF::chunk *,std::allocator< DFF::chunk * > >())
        __setslice__(VectChunk self, std::vector< DFF::chunk * >::difference_type i, std::vector< DFF::chunk * >::difference_type j)

        1
        """
        return _libvfs.VectChunk___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(VectChunk self, std::vector< DFF::chunk * >::difference_type i, std::vector< DFF::chunk * >::difference_type j)

        1
        """
        return _libvfs.VectChunk___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(VectChunk self, std::vector< DFF::chunk * >::difference_type i)
        __delitem__(VectChunk self, PySliceObject * slice)

        1
        """
        return _libvfs.VectChunk___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(VectChunk self, PySliceObject * slice) -> VectChunk
        __getitem__(VectChunk self, std::vector< DFF::chunk * >::difference_type i) -> chunk

        1
        """
        return _libvfs.VectChunk___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(VectChunk self, PySliceObject * slice, VectChunk v)
        __setitem__(VectChunk self, PySliceObject * slice)
        __setitem__(VectChunk self, std::vector< DFF::chunk * >::difference_type i, chunk x)

        1
        """
        return _libvfs.VectChunk___setitem__(self, *args)

    def append(self, *args):
        """
        append(VectChunk self, chunk x)

        1
        """
        return _libvfs.VectChunk_append(self, *args)

    def empty(self):
        """
        empty(VectChunk self) -> bool

        1
        """
        return _libvfs.VectChunk_empty(self)

    def size(self):
        """
        size(VectChunk self) -> std::vector< DFF::chunk * >::size_type

        1
        """
        return _libvfs.VectChunk_size(self)

    def clear(self):
        """
        clear(VectChunk self)

        1
        """
        return _libvfs.VectChunk_clear(self)

    def swap(self, *args):
        """
        swap(VectChunk self, VectChunk v)

        1
        """
        return _libvfs.VectChunk_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(VectChunk self) -> std::vector< DFF::chunk * >::allocator_type

        1
        """
        return _libvfs.VectChunk_get_allocator(self)

    def begin(self):
        """
        begin(VectChunk self) -> std::vector< DFF::chunk * >::iterator

        1
        """
        return _libvfs.VectChunk_begin(self)

    def end(self):
        """
        end(VectChunk self) -> std::vector< DFF::chunk * >::iterator

        1
        """
        return _libvfs.VectChunk_end(self)

    def rbegin(self):
        """
        rbegin(VectChunk self) -> std::vector< DFF::chunk * >::reverse_iterator

        1
        """
        return _libvfs.VectChunk_rbegin(self)

    def rend(self):
        """
        rend(VectChunk self) -> std::vector< DFF::chunk * >::reverse_iterator

        1
        """
        return _libvfs.VectChunk_rend(self)

    def pop_back(self):
        """
        pop_back(VectChunk self)

        1
        """
        return _libvfs.VectChunk_pop_back(self)

    def erase(self, *args):
        """
        erase(VectChunk self, std::vector< DFF::chunk * >::iterator pos) -> std::vector< DFF::chunk * >::iterator
        erase(VectChunk self, std::vector< DFF::chunk * >::iterator first, std::vector< DFF::chunk * >::iterator last) -> std::vector< DFF::chunk * >::iterator

        1
        """
        return _libvfs.VectChunk_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.DFF::chunk)> self) -> VectChunk
        __init__(std::vector<(p.DFF::chunk)> self, VectChunk arg2) -> VectChunk
        __init__(std::vector<(p.DFF::chunk)> self, std::vector< DFF::chunk * >::size_type size) -> VectChunk
        __init__(std::vector<(p.DFF::chunk)> self, std::vector< DFF::chunk * >::size_type size, chunk value) -> VectChunk

        1
        """
        this = _libvfs.new_VectChunk(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(VectChunk self, chunk x)

        1
        """
        return _libvfs.VectChunk_push_back(self, *args)

    def front(self):
        """
        front(VectChunk self) -> chunk

        1
        """
        return _libvfs.VectChunk_front(self)

    def back(self):
        """
        back(VectChunk self) -> chunk

        1
        """
        return _libvfs.VectChunk_back(self)

    def assign(self, *args):
        """
        assign(VectChunk self, std::vector< DFF::chunk * >::size_type n, chunk x)

        1
        """
        return _libvfs.VectChunk_assign(self, *args)

    def resize(self, *args):
        """
        resize(VectChunk self, std::vector< DFF::chunk * >::size_type new_size)
        resize(VectChunk self, std::vector< DFF::chunk * >::size_type new_size, chunk x)

        1
        """
        return _libvfs.VectChunk_resize(self, *args)

    def insert(self, *args):
        """
        insert(VectChunk self, std::vector< DFF::chunk * >::iterator pos, chunk x) -> std::vector< DFF::chunk * >::iterator
        insert(VectChunk self, std::vector< DFF::chunk * >::iterator pos, std::vector< DFF::chunk * >::size_type n, 
            chunk x)

        1
        """
        return _libvfs.VectChunk_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(VectChunk self, std::vector< DFF::chunk * >::size_type n)

        1
        """
        return _libvfs.VectChunk_reserve(self, *args)

    def capacity(self):
        """
        capacity(VectChunk self) -> std::vector< DFF::chunk * >::size_type

        1
        """
        return _libvfs.VectChunk_capacity(self)

    __swig_destroy__ = _libvfs.delete_VectChunk
    __del__ = lambda self : None;
VectChunk_swigregister = _libvfs.VectChunk_swigregister
VectChunk_swigregister(VectChunk)

class Listui64(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listui64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listui64, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(Listui64 self) -> SwigPyIterator

        1
        """
        return _libvfs.Listui64_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(Listui64 self) -> bool

        1
        """
        return _libvfs.Listui64___nonzero__(self)

    def __bool__(self):
        """
        __bool__(Listui64 self) -> bool

        1
        """
        return _libvfs.Listui64___bool__(self)

    def __len__(self):
        """
        __len__(Listui64 self) -> std::list< unsigned long >::size_type

        1
        """
        return _libvfs.Listui64___len__(self)

    def pop(self):
        """
        pop(Listui64 self) -> std::list< unsigned long >::value_type

        1
        """
        return _libvfs.Listui64_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(Listui64 self, std::list< unsigned long >::difference_type i, std::list< unsigned long >::difference_type j) -> Listui64

        1
        """
        return _libvfs.Listui64___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(Listui64 self, std::list< unsigned long >::difference_type i, std::list< unsigned long >::difference_type j, 
            Listui64 v=std::list< unsigned long,std::allocator< unsigned long > >())
        __setslice__(Listui64 self, std::list< unsigned long >::difference_type i, std::list< unsigned long >::difference_type j)

        1
        """
        return _libvfs.Listui64___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(Listui64 self, std::list< unsigned long >::difference_type i, std::list< unsigned long >::difference_type j)

        1
        """
        return _libvfs.Listui64___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(Listui64 self, std::list< unsigned long >::difference_type i)
        __delitem__(Listui64 self, PySliceObject * slice)

        1
        """
        return _libvfs.Listui64___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(Listui64 self, PySliceObject * slice) -> Listui64
        __getitem__(Listui64 self, std::list< unsigned long >::difference_type i) -> std::list< unsigned long >::value_type const &

        1
        """
        return _libvfs.Listui64___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(Listui64 self, PySliceObject * slice, Listui64 v)
        __setitem__(Listui64 self, PySliceObject * slice)
        __setitem__(Listui64 self, std::list< unsigned long >::difference_type i, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64___setitem__(self, *args)

    def append(self, *args):
        """
        append(Listui64 self, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_append(self, *args)

    def empty(self):
        """
        empty(Listui64 self) -> bool

        1
        """
        return _libvfs.Listui64_empty(self)

    def size(self):
        """
        size(Listui64 self) -> std::list< unsigned long >::size_type

        1
        """
        return _libvfs.Listui64_size(self)

    def clear(self):
        """
        clear(Listui64 self)

        1
        """
        return _libvfs.Listui64_clear(self)

    def swap(self, *args):
        """
        swap(Listui64 self, Listui64 v)

        1
        """
        return _libvfs.Listui64_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(Listui64 self) -> std::list< unsigned long >::allocator_type

        1
        """
        return _libvfs.Listui64_get_allocator(self)

    def begin(self):
        """
        begin(Listui64 self) -> std::list< unsigned long >::iterator

        1
        """
        return _libvfs.Listui64_begin(self)

    def end(self):
        """
        end(Listui64 self) -> std::list< unsigned long >::iterator

        1
        """
        return _libvfs.Listui64_end(self)

    def rbegin(self):
        """
        rbegin(Listui64 self) -> std::list< unsigned long >::reverse_iterator

        1
        """
        return _libvfs.Listui64_rbegin(self)

    def rend(self):
        """
        rend(Listui64 self) -> std::list< unsigned long >::reverse_iterator

        1
        """
        return _libvfs.Listui64_rend(self)

    def pop_back(self):
        """
        pop_back(Listui64 self)

        1
        """
        return _libvfs.Listui64_pop_back(self)

    def erase(self, *args):
        """
        erase(Listui64 self, std::list< unsigned long >::iterator pos) -> std::list< unsigned long >::iterator
        erase(Listui64 self, std::list< unsigned long >::iterator first, std::list< unsigned long >::iterator last) -> std::list< unsigned long >::iterator

        1
        """
        return _libvfs.Listui64_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(uint64_t)> self) -> Listui64
        __init__(std::list<(uint64_t)> self, Listui64 arg2) -> Listui64
        __init__(std::list<(uint64_t)> self, std::list< unsigned long >::size_type size) -> Listui64
        __init__(std::list<(uint64_t)> self, std::list< unsigned long >::size_type size, std::list< unsigned long >::value_type const & value) -> Listui64

        1
        """
        this = _libvfs.new_Listui64(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(Listui64 self, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_push_back(self, *args)

    def front(self):
        """
        front(Listui64 self) -> std::list< unsigned long >::value_type const &

        1
        """
        return _libvfs.Listui64_front(self)

    def back(self):
        """
        back(Listui64 self) -> std::list< unsigned long >::value_type const &

        1
        """
        return _libvfs.Listui64_back(self)

    def assign(self, *args):
        """
        assign(Listui64 self, std::list< unsigned long >::size_type n, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_assign(self, *args)

    def resize(self, *args):
        """
        resize(Listui64 self, std::list< unsigned long >::size_type new_size)
        resize(Listui64 self, std::list< unsigned long >::size_type new_size, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_resize(self, *args)

    def insert(self, *args):
        """
        insert(Listui64 self, std::list< unsigned long >::iterator pos, std::list< unsigned long >::value_type const & x) -> std::list< unsigned long >::iterator
        insert(Listui64 self, std::list< unsigned long >::iterator pos, std::list< unsigned long >::size_type n, 
            std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_insert(self, *args)

    def pop_front(self):
        """
        pop_front(Listui64 self)

        1
        """
        return _libvfs.Listui64_pop_front(self)

    def push_front(self, *args):
        """
        push_front(Listui64 self, std::list< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Listui64_push_front(self, *args)

    def reverse(self):
        """
        reverse(Listui64 self)

        1
        """
        return _libvfs.Listui64_reverse(self)

    __swig_destroy__ = _libvfs.delete_Listui64
    __del__ = lambda self : None;
Listui64_swigregister = _libvfs.Listui64_swigregister
Listui64_swigregister(Listui64)

class Vectui64(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vectui64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vectui64, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(Vectui64 self) -> SwigPyIterator

        1
        """
        return _libvfs.Vectui64_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(Vectui64 self) -> bool

        1
        """
        return _libvfs.Vectui64___nonzero__(self)

    def __bool__(self):
        """
        __bool__(Vectui64 self) -> bool

        1
        """
        return _libvfs.Vectui64___bool__(self)

    def __len__(self):
        """
        __len__(Vectui64 self) -> std::vector< unsigned long >::size_type

        1
        """
        return _libvfs.Vectui64___len__(self)

    def pop(self):
        """
        pop(Vectui64 self) -> std::vector< unsigned long >::value_type

        1
        """
        return _libvfs.Vectui64_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(Vectui64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> Vectui64

        1
        """
        return _libvfs.Vectui64___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(Vectui64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, 
            Vectui64 v=std::vector< unsigned long,std::allocator< unsigned long > >())
        __setslice__(Vectui64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)

        1
        """
        return _libvfs.Vectui64___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(Vectui64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)

        1
        """
        return _libvfs.Vectui64___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(Vectui64 self, std::vector< unsigned long >::difference_type i)
        __delitem__(Vectui64 self, PySliceObject * slice)

        1
        """
        return _libvfs.Vectui64___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(Vectui64 self, PySliceObject * slice) -> Vectui64
        __getitem__(Vectui64 self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &

        1
        """
        return _libvfs.Vectui64___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(Vectui64 self, PySliceObject * slice, Vectui64 v)
        __setitem__(Vectui64 self, PySliceObject * slice)
        __setitem__(Vectui64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64___setitem__(self, *args)

    def append(self, *args):
        """
        append(Vectui64 self, std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64_append(self, *args)

    def empty(self):
        """
        empty(Vectui64 self) -> bool

        1
        """
        return _libvfs.Vectui64_empty(self)

    def size(self):
        """
        size(Vectui64 self) -> std::vector< unsigned long >::size_type

        1
        """
        return _libvfs.Vectui64_size(self)

    def clear(self):
        """
        clear(Vectui64 self)

        1
        """
        return _libvfs.Vectui64_clear(self)

    def swap(self, *args):
        """
        swap(Vectui64 self, Vectui64 v)

        1
        """
        return _libvfs.Vectui64_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(Vectui64 self) -> std::vector< unsigned long >::allocator_type

        1
        """
        return _libvfs.Vectui64_get_allocator(self)

    def begin(self):
        """
        begin(Vectui64 self) -> std::vector< unsigned long >::iterator

        1
        """
        return _libvfs.Vectui64_begin(self)

    def end(self):
        """
        end(Vectui64 self) -> std::vector< unsigned long >::iterator

        1
        """
        return _libvfs.Vectui64_end(self)

    def rbegin(self):
        """
        rbegin(Vectui64 self) -> std::vector< unsigned long >::reverse_iterator

        1
        """
        return _libvfs.Vectui64_rbegin(self)

    def rend(self):
        """
        rend(Vectui64 self) -> std::vector< unsigned long >::reverse_iterator

        1
        """
        return _libvfs.Vectui64_rend(self)

    def pop_back(self):
        """
        pop_back(Vectui64 self)

        1
        """
        return _libvfs.Vectui64_pop_back(self)

    def erase(self, *args):
        """
        erase(Vectui64 self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(Vectui64 self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator

        1
        """
        return _libvfs.Vectui64_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(uint64_t)> self) -> Vectui64
        __init__(std::vector<(uint64_t)> self, Vectui64 arg2) -> Vectui64
        __init__(std::vector<(uint64_t)> self, std::vector< unsigned long >::size_type size) -> Vectui64
        __init__(std::vector<(uint64_t)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> Vectui64

        1
        """
        this = _libvfs.new_Vectui64(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(Vectui64 self, std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64_push_back(self, *args)

    def front(self):
        """
        front(Vectui64 self) -> std::vector< unsigned long >::value_type const &

        1
        """
        return _libvfs.Vectui64_front(self)

    def back(self):
        """
        back(Vectui64 self) -> std::vector< unsigned long >::value_type const &

        1
        """
        return _libvfs.Vectui64_back(self)

    def assign(self, *args):
        """
        assign(Vectui64 self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64_assign(self, *args)

    def resize(self, *args):
        """
        resize(Vectui64 self, std::vector< unsigned long >::size_type new_size)
        resize(Vectui64 self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64_resize(self, *args)

    def insert(self, *args):
        """
        insert(Vectui64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(Vectui64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, 
            std::vector< unsigned long >::value_type const & x)

        1
        """
        return _libvfs.Vectui64_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(Vectui64 self, std::vector< unsigned long >::size_type n)

        1
        """
        return _libvfs.Vectui64_reserve(self, *args)

    def capacity(self):
        """
        capacity(Vectui64 self) -> std::vector< unsigned long >::size_type

        1
        """
        return _libvfs.Vectui64_capacity(self)

    __swig_destroy__ = _libvfs.delete_Vectui64
    __del__ = lambda self : None;
Vectui64_swigregister = _libvfs.Vectui64_swigregister
Vectui64_swigregister(Vectui64)

class Vectui32(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vectui32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vectui32, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(Vectui32 self) -> SwigPyIterator

        1
        """
        return _libvfs.Vectui32_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(Vectui32 self) -> bool

        1
        """
        return _libvfs.Vectui32___nonzero__(self)

    def __bool__(self):
        """
        __bool__(Vectui32 self) -> bool

        1
        """
        return _libvfs.Vectui32___bool__(self)

    def __len__(self):
        """
        __len__(Vectui32 self) -> std::vector< unsigned int >::size_type

        1
        """
        return _libvfs.Vectui32___len__(self)

    def pop(self):
        """
        pop(Vectui32 self) -> std::vector< unsigned int >::value_type

        1
        """
        return _libvfs.Vectui32_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(Vectui32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> Vectui32

        1
        """
        return _libvfs.Vectui32___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(Vectui32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            Vectui32 v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(Vectui32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)

        1
        """
        return _libvfs.Vectui32___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(Vectui32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)

        1
        """
        return _libvfs.Vectui32___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(Vectui32 self, std::vector< unsigned int >::difference_type i)
        __delitem__(Vectui32 self, PySliceObject * slice)

        1
        """
        return _libvfs.Vectui32___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(Vectui32 self, PySliceObject * slice) -> Vectui32
        __getitem__(Vectui32 self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &

        1
        """
        return _libvfs.Vectui32___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(Vectui32 self, PySliceObject * slice, Vectui32 v)
        __setitem__(Vectui32 self, PySliceObject * slice)
        __setitem__(Vectui32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32___setitem__(self, *args)

    def append(self, *args):
        """
        append(Vectui32 self, std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32_append(self, *args)

    def empty(self):
        """
        empty(Vectui32 self) -> bool

        1
        """
        return _libvfs.Vectui32_empty(self)

    def size(self):
        """
        size(Vectui32 self) -> std::vector< unsigned int >::size_type

        1
        """
        return _libvfs.Vectui32_size(self)

    def clear(self):
        """
        clear(Vectui32 self)

        1
        """
        return _libvfs.Vectui32_clear(self)

    def swap(self, *args):
        """
        swap(Vectui32 self, Vectui32 v)

        1
        """
        return _libvfs.Vectui32_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(Vectui32 self) -> std::vector< unsigned int >::allocator_type

        1
        """
        return _libvfs.Vectui32_get_allocator(self)

    def begin(self):
        """
        begin(Vectui32 self) -> std::vector< unsigned int >::iterator

        1
        """
        return _libvfs.Vectui32_begin(self)

    def end(self):
        """
        end(Vectui32 self) -> std::vector< unsigned int >::iterator

        1
        """
        return _libvfs.Vectui32_end(self)

    def rbegin(self):
        """
        rbegin(Vectui32 self) -> std::vector< unsigned int >::reverse_iterator

        1
        """
        return _libvfs.Vectui32_rbegin(self)

    def rend(self):
        """
        rend(Vectui32 self) -> std::vector< unsigned int >::reverse_iterator

        1
        """
        return _libvfs.Vectui32_rend(self)

    def pop_back(self):
        """
        pop_back(Vectui32 self)

        1
        """
        return _libvfs.Vectui32_pop_back(self)

    def erase(self, *args):
        """
        erase(Vectui32 self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(Vectui32 self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator

        1
        """
        return _libvfs.Vectui32_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(uint32_t)> self) -> Vectui32
        __init__(std::vector<(uint32_t)> self, Vectui32 arg2) -> Vectui32
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size) -> Vectui32
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> Vectui32

        1
        """
        this = _libvfs.new_Vectui32(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(Vectui32 self, std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32_push_back(self, *args)

    def front(self):
        """
        front(Vectui32 self) -> std::vector< unsigned int >::value_type const &

        1
        """
        return _libvfs.Vectui32_front(self)

    def back(self):
        """
        back(Vectui32 self) -> std::vector< unsigned int >::value_type const &

        1
        """
        return _libvfs.Vectui32_back(self)

    def assign(self, *args):
        """
        assign(Vectui32 self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32_assign(self, *args)

    def resize(self, *args):
        """
        resize(Vectui32 self, std::vector< unsigned int >::size_type new_size)
        resize(Vectui32 self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32_resize(self, *args)

    def insert(self, *args):
        """
        insert(Vectui32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(Vectui32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)

        1
        """
        return _libvfs.Vectui32_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(Vectui32 self, std::vector< unsigned int >::size_type n)

        1
        """
        return _libvfs.Vectui32_reserve(self, *args)

    def capacity(self):
        """
        capacity(Vectui32 self) -> std::vector< unsigned int >::size_type

        1
        """
        return _libvfs.Vectui32_capacity(self)

    __swig_destroy__ = _libvfs.delete_Vectui32
    __del__ = lambda self : None;
Vectui32_swigregister = _libvfs.Vectui32_swigregister
Vectui32_swigregister(Vectui32)

class MapTime(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapTime, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(MapTime self) -> SwigPyIterator

        1
        """
        return _libvfs.MapTime_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(MapTime self) -> bool

        1
        """
        return _libvfs.MapTime___nonzero__(self)

    def __bool__(self):
        """
        __bool__(MapTime self) -> bool

        1
        """
        return _libvfs.MapTime___bool__(self)

    def __len__(self):
        """
        __len__(MapTime self) -> std::map< std::string,DFF::DateTime * >::size_type

        1
        """
        return _libvfs.MapTime___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """
        __getitem__(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key) -> DateTime

        1
        """
        return _libvfs.MapTime___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key)

        1
        """
        return _libvfs.MapTime___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key) -> bool

        1
        """
        return _libvfs.MapTime_has_key(self, *args)

    def keys(self):
        """
        keys(MapTime self) -> PyObject *

        1
        """
        return _libvfs.MapTime_keys(self)

    def values(self):
        """
        values(MapTime self) -> PyObject *

        1
        """
        return _libvfs.MapTime_values(self)

    def items(self):
        """
        items(MapTime self) -> PyObject *

        1
        """
        return _libvfs.MapTime_items(self)

    def __contains__(self, *args):
        """
        __contains__(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key) -> bool

        1
        """
        return _libvfs.MapTime___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(MapTime self) -> SwigPyIterator

        1
        """
        return _libvfs.MapTime_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(MapTime self) -> SwigPyIterator

        1
        """
        return _libvfs.MapTime_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key)
        __setitem__(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & key, DateTime x)

        1
        """
        return _libvfs.MapTime___setitem__(self, *args)

    def asdict(self):
        """
        asdict(MapTime self) -> PyObject *

        1
        """
        return _libvfs.MapTime_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,p.DFF::DateTime)> self, std::less< std::string > const & arg2) -> MapTime
        __init__(std::map<(std::string,p.DFF::DateTime)> self) -> MapTime
        __init__(std::map<(std::string,p.DFF::DateTime)> self, MapDateTime arg2) -> MapTime

        1
        """
        this = _libvfs.new_MapTime(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(MapTime self) -> bool

        1
        """
        return _libvfs.MapTime_empty(self)

    def size(self):
        """
        size(MapTime self) -> std::map< std::string,DFF::DateTime * >::size_type

        1
        """
        return _libvfs.MapTime_size(self)

    def clear(self):
        """
        clear(MapTime self)

        1
        """
        return _libvfs.MapTime_clear(self)

    def swap(self, *args):
        """
        swap(MapTime self, MapDateTime v)

        1
        """
        return _libvfs.MapTime_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(MapTime self) -> std::map< std::string,DFF::DateTime * >::allocator_type

        1
        """
        return _libvfs.MapTime_get_allocator(self)

    def begin(self):
        """
        begin(MapTime self) -> std::map< std::string,DFF::DateTime * >::iterator

        1
        """
        return _libvfs.MapTime_begin(self)

    def end(self):
        """
        end(MapTime self) -> std::map< std::string,DFF::DateTime * >::iterator

        1
        """
        return _libvfs.MapTime_end(self)

    def rbegin(self):
        """
        rbegin(MapTime self) -> std::map< std::string,DFF::DateTime * >::reverse_iterator

        1
        """
        return _libvfs.MapTime_rbegin(self)

    def rend(self):
        """
        rend(MapTime self) -> std::map< std::string,DFF::DateTime * >::reverse_iterator

        1
        """
        return _libvfs.MapTime_rend(self)

    def count(self, *args):
        """
        count(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & x) -> std::map< std::string,DFF::DateTime * >::size_type

        1
        """
        return _libvfs.MapTime_count(self, *args)

    def erase(self, *args):
        """
        erase(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & x) -> std::map< std::string,DFF::DateTime * >::size_type
        erase(MapTime self, std::map< std::string,DFF::DateTime * >::iterator position)
        erase(MapTime self, std::map< std::string,DFF::DateTime * >::iterator first, std::map< std::string,DFF::DateTime * >::iterator last)

        1
        """
        return _libvfs.MapTime_erase(self, *args)

    def find(self, *args):
        """
        find(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & x) -> std::map< std::string,DFF::DateTime * >::iterator

        1
        """
        return _libvfs.MapTime_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & x) -> std::map< std::string,DFF::DateTime * >::iterator

        1
        """
        return _libvfs.MapTime_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(MapTime self, std::map< std::string,DFF::DateTime * >::key_type const & x) -> std::map< std::string,DFF::DateTime * >::iterator

        1
        """
        return _libvfs.MapTime_upper_bound(self, *args)

    __swig_destroy__ = _libvfs.delete_MapTime
    __del__ = lambda self : None;
MapTime_swigregister = _libvfs.MapTime_swigregister
MapTime_swigregister(MapTime)

class MapNameTypes(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapNameTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapNameTypes, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(MapNameTypes self) -> SwigPyIterator

        1
        """
        return _libvfs.MapNameTypes_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(MapNameTypes self) -> bool

        1
        """
        return _libvfs.MapNameTypes___nonzero__(self)

    def __bool__(self):
        """
        __bool__(MapNameTypes self) -> bool

        1
        """
        return _libvfs.MapNameTypes___bool__(self)

    def __len__(self):
        """
        __len__(MapNameTypes self) -> std::map< std::string,unsigned char >::size_type

        1
        """
        return _libvfs.MapNameTypes___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """
        __getitem__(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key) -> std::map< std::string,unsigned char >::mapped_type const &

        1
        """
        return _libvfs.MapNameTypes___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key)

        1
        """
        return _libvfs.MapNameTypes___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key) -> bool

        1
        """
        return _libvfs.MapNameTypes_has_key(self, *args)

    def keys(self):
        """
        keys(MapNameTypes self) -> PyObject *

        1
        """
        return _libvfs.MapNameTypes_keys(self)

    def values(self):
        """
        values(MapNameTypes self) -> PyObject *

        1
        """
        return _libvfs.MapNameTypes_values(self)

    def items(self):
        """
        items(MapNameTypes self) -> PyObject *

        1
        """
        return _libvfs.MapNameTypes_items(self)

    def __contains__(self, *args):
        """
        __contains__(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key) -> bool

        1
        """
        return _libvfs.MapNameTypes___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(MapNameTypes self) -> SwigPyIterator

        1
        """
        return _libvfs.MapNameTypes_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(MapNameTypes self) -> SwigPyIterator

        1
        """
        return _libvfs.MapNameTypes_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key)
        __setitem__(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & key, std::map< std::string,unsigned char >::mapped_type const & x)

        1
        """
        return _libvfs.MapNameTypes___setitem__(self, *args)

    def asdict(self):
        """
        asdict(MapNameTypes self) -> PyObject *

        1
        """
        return _libvfs.MapNameTypes_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,uint8_t)> self, std::less< std::string > const & arg2) -> MapNameTypes
        __init__(std::map<(std::string,uint8_t)> self) -> MapNameTypes
        __init__(std::map<(std::string,uint8_t)> self, MapNameTypes arg2) -> MapNameTypes

        1
        """
        this = _libvfs.new_MapNameTypes(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(MapNameTypes self) -> bool

        1
        """
        return _libvfs.MapNameTypes_empty(self)

    def size(self):
        """
        size(MapNameTypes self) -> std::map< std::string,unsigned char >::size_type

        1
        """
        return _libvfs.MapNameTypes_size(self)

    def clear(self):
        """
        clear(MapNameTypes self)

        1
        """
        return _libvfs.MapNameTypes_clear(self)

    def swap(self, *args):
        """
        swap(MapNameTypes self, MapNameTypes v)

        1
        """
        return _libvfs.MapNameTypes_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(MapNameTypes self) -> std::map< std::string,unsigned char >::allocator_type

        1
        """
        return _libvfs.MapNameTypes_get_allocator(self)

    def begin(self):
        """
        begin(MapNameTypes self) -> std::map< std::string,unsigned char >::iterator

        1
        """
        return _libvfs.MapNameTypes_begin(self)

    def end(self):
        """
        end(MapNameTypes self) -> std::map< std::string,unsigned char >::iterator

        1
        """
        return _libvfs.MapNameTypes_end(self)

    def rbegin(self):
        """
        rbegin(MapNameTypes self) -> std::map< std::string,unsigned char >::reverse_iterator

        1
        """
        return _libvfs.MapNameTypes_rbegin(self)

    def rend(self):
        """
        rend(MapNameTypes self) -> std::map< std::string,unsigned char >::reverse_iterator

        1
        """
        return _libvfs.MapNameTypes_rend(self)

    def count(self, *args):
        """
        count(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::size_type

        1
        """
        return _libvfs.MapNameTypes_count(self, *args)

    def erase(self, *args):
        """
        erase(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::size_type
        erase(MapNameTypes self, std::map< std::string,unsigned char >::iterator position)
        erase(MapNameTypes self, std::map< std::string,unsigned char >::iterator first, std::map< std::string,unsigned char >::iterator last)

        1
        """
        return _libvfs.MapNameTypes_erase(self, *args)

    def find(self, *args):
        """
        find(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator

        1
        """
        return _libvfs.MapNameTypes_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator

        1
        """
        return _libvfs.MapNameTypes_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(MapNameTypes self, std::map< std::string,unsigned char >::key_type const & x) -> std::map< std::string,unsigned char >::iterator

        1
        """
        return _libvfs.MapNameTypes_upper_bound(self, *args)

    __swig_destroy__ = _libvfs.delete_MapNameTypes
    __del__ = lambda self : None;
MapNameTypes_swigregister = _libvfs.MapNameTypes_swigregister
MapNameTypes_swigregister(MapNameTypes)

class FsoVect(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FsoVect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FsoVect, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(FsoVect self) -> SwigPyIterator

        1
        """
        return _libvfs.FsoVect_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(FsoVect self) -> bool

        1
        """
        return _libvfs.FsoVect___nonzero__(self)

    def __bool__(self):
        """
        __bool__(FsoVect self) -> bool

        1
        """
        return _libvfs.FsoVect___bool__(self)

    def __len__(self):
        """
        __len__(FsoVect self) -> std::vector< DFF::fso * >::size_type

        1
        """
        return _libvfs.FsoVect___len__(self)

    def pop(self):
        """
        pop(FsoVect self) -> fso

        1
        """
        return _libvfs.FsoVect_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(FsoVect self, std::vector< DFF::fso * >::difference_type i, std::vector< DFF::fso * >::difference_type j) -> FsoVect

        1
        """
        return _libvfs.FsoVect___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(FsoVect self, std::vector< DFF::fso * >::difference_type i, std::vector< DFF::fso * >::difference_type j, 
            FsoVect v=std::vector< DFF::fso *,std::allocator< DFF::fso * > >())
        __setslice__(FsoVect self, std::vector< DFF::fso * >::difference_type i, std::vector< DFF::fso * >::difference_type j)

        1
        """
        return _libvfs.FsoVect___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(FsoVect self, std::vector< DFF::fso * >::difference_type i, std::vector< DFF::fso * >::difference_type j)

        1
        """
        return _libvfs.FsoVect___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(FsoVect self, std::vector< DFF::fso * >::difference_type i)
        __delitem__(FsoVect self, PySliceObject * slice)

        1
        """
        return _libvfs.FsoVect___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(FsoVect self, PySliceObject * slice) -> FsoVect
        __getitem__(FsoVect self, std::vector< DFF::fso * >::difference_type i) -> fso

        1
        """
        return _libvfs.FsoVect___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(FsoVect self, PySliceObject * slice, FsoVect v)
        __setitem__(FsoVect self, PySliceObject * slice)
        __setitem__(FsoVect self, std::vector< DFF::fso * >::difference_type i, fso x)

        1
        """
        return _libvfs.FsoVect___setitem__(self, *args)

    def append(self, *args):
        """
        append(FsoVect self, fso x)

        1
        """
        return _libvfs.FsoVect_append(self, *args)

    def empty(self):
        """
        empty(FsoVect self) -> bool

        1
        """
        return _libvfs.FsoVect_empty(self)

    def size(self):
        """
        size(FsoVect self) -> std::vector< DFF::fso * >::size_type

        1
        """
        return _libvfs.FsoVect_size(self)

    def clear(self):
        """
        clear(FsoVect self)

        1
        """
        return _libvfs.FsoVect_clear(self)

    def swap(self, *args):
        """
        swap(FsoVect self, FsoVect v)

        1
        """
        return _libvfs.FsoVect_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(FsoVect self) -> std::vector< DFF::fso * >::allocator_type

        1
        """
        return _libvfs.FsoVect_get_allocator(self)

    def begin(self):
        """
        begin(FsoVect self) -> std::vector< DFF::fso * >::iterator

        1
        """
        return _libvfs.FsoVect_begin(self)

    def end(self):
        """
        end(FsoVect self) -> std::vector< DFF::fso * >::iterator

        1
        """
        return _libvfs.FsoVect_end(self)

    def rbegin(self):
        """
        rbegin(FsoVect self) -> std::vector< DFF::fso * >::reverse_iterator

        1
        """
        return _libvfs.FsoVect_rbegin(self)

    def rend(self):
        """
        rend(FsoVect self) -> std::vector< DFF::fso * >::reverse_iterator

        1
        """
        return _libvfs.FsoVect_rend(self)

    def pop_back(self):
        """
        pop_back(FsoVect self)

        1
        """
        return _libvfs.FsoVect_pop_back(self)

    def erase(self, *args):
        """
        erase(FsoVect self, std::vector< DFF::fso * >::iterator pos) -> std::vector< DFF::fso * >::iterator
        erase(FsoVect self, std::vector< DFF::fso * >::iterator first, std::vector< DFF::fso * >::iterator last) -> std::vector< DFF::fso * >::iterator

        1
        """
        return _libvfs.FsoVect_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.DFF::fso)> self) -> FsoVect
        __init__(std::vector<(p.DFF::fso)> self, FsoVect arg2) -> FsoVect
        __init__(std::vector<(p.DFF::fso)> self, std::vector< DFF::fso * >::size_type size) -> FsoVect
        __init__(std::vector<(p.DFF::fso)> self, std::vector< DFF::fso * >::size_type size, fso value) -> FsoVect

        1
        """
        this = _libvfs.new_FsoVect(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(FsoVect self, fso x)

        1
        """
        return _libvfs.FsoVect_push_back(self, *args)

    def front(self):
        """
        front(FsoVect self) -> fso

        1
        """
        return _libvfs.FsoVect_front(self)

    def back(self):
        """
        back(FsoVect self) -> fso

        1
        """
        return _libvfs.FsoVect_back(self)

    def assign(self, *args):
        """
        assign(FsoVect self, std::vector< DFF::fso * >::size_type n, fso x)

        1
        """
        return _libvfs.FsoVect_assign(self, *args)

    def resize(self, *args):
        """
        resize(FsoVect self, std::vector< DFF::fso * >::size_type new_size)
        resize(FsoVect self, std::vector< DFF::fso * >::size_type new_size, fso x)

        1
        """
        return _libvfs.FsoVect_resize(self, *args)

    def insert(self, *args):
        """
        insert(FsoVect self, std::vector< DFF::fso * >::iterator pos, fso x) -> std::vector< DFF::fso * >::iterator
        insert(FsoVect self, std::vector< DFF::fso * >::iterator pos, std::vector< DFF::fso * >::size_type n, 
            fso x)

        1
        """
        return _libvfs.FsoVect_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(FsoVect self, std::vector< DFF::fso * >::size_type n)

        1
        """
        return _libvfs.FsoVect_reserve(self, *args)

    def capacity(self):
        """
        capacity(FsoVect self) -> std::vector< DFF::fso * >::size_type

        1
        """
        return _libvfs.FsoVect_capacity(self)

    __swig_destroy__ = _libvfs.delete_FsoVect
    __del__ = lambda self : None;
FsoVect_swigregister = _libvfs.FsoVect_swigregister
FsoVect_swigregister(FsoVect)

class TagVect(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagVect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TagVect, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(TagVect self) -> SwigPyIterator

        1
        """
        return _libvfs.TagVect_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(TagVect self) -> bool

        1
        """
        return _libvfs.TagVect___nonzero__(self)

    def __bool__(self):
        """
        __bool__(TagVect self) -> bool

        1
        """
        return _libvfs.TagVect___bool__(self)

    def __len__(self):
        """
        __len__(TagVect self) -> std::vector< DFF::Tag * >::size_type

        1
        """
        return _libvfs.TagVect___len__(self)

    def pop(self):
        """
        pop(TagVect self) -> Tag

        1
        """
        return _libvfs.TagVect_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(TagVect self, std::vector< DFF::Tag * >::difference_type i, std::vector< DFF::Tag * >::difference_type j) -> TagVect

        1
        """
        return _libvfs.TagVect___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(TagVect self, std::vector< DFF::Tag * >::difference_type i, std::vector< DFF::Tag * >::difference_type j, 
            TagVect v=std::vector< DFF::Tag *,std::allocator< DFF::Tag * > >())
        __setslice__(TagVect self, std::vector< DFF::Tag * >::difference_type i, std::vector< DFF::Tag * >::difference_type j)

        1
        """
        return _libvfs.TagVect___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(TagVect self, std::vector< DFF::Tag * >::difference_type i, std::vector< DFF::Tag * >::difference_type j)

        1
        """
        return _libvfs.TagVect___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(TagVect self, std::vector< DFF::Tag * >::difference_type i)
        __delitem__(TagVect self, PySliceObject * slice)

        1
        """
        return _libvfs.TagVect___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(TagVect self, PySliceObject * slice) -> TagVect
        __getitem__(TagVect self, std::vector< DFF::Tag * >::difference_type i) -> Tag

        1
        """
        return _libvfs.TagVect___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(TagVect self, PySliceObject * slice, TagVect v)
        __setitem__(TagVect self, PySliceObject * slice)
        __setitem__(TagVect self, std::vector< DFF::Tag * >::difference_type i, Tag x)

        1
        """
        return _libvfs.TagVect___setitem__(self, *args)

    def append(self, *args):
        """
        append(TagVect self, Tag x)

        1
        """
        return _libvfs.TagVect_append(self, *args)

    def empty(self):
        """
        empty(TagVect self) -> bool

        1
        """
        return _libvfs.TagVect_empty(self)

    def size(self):
        """
        size(TagVect self) -> std::vector< DFF::Tag * >::size_type

        1
        """
        return _libvfs.TagVect_size(self)

    def clear(self):
        """
        clear(TagVect self)

        1
        """
        return _libvfs.TagVect_clear(self)

    def swap(self, *args):
        """
        swap(TagVect self, TagVect v)

        1
        """
        return _libvfs.TagVect_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(TagVect self) -> std::vector< DFF::Tag * >::allocator_type

        1
        """
        return _libvfs.TagVect_get_allocator(self)

    def begin(self):
        """
        begin(TagVect self) -> std::vector< DFF::Tag * >::iterator

        1
        """
        return _libvfs.TagVect_begin(self)

    def end(self):
        """
        end(TagVect self) -> std::vector< DFF::Tag * >::iterator

        1
        """
        return _libvfs.TagVect_end(self)

    def rbegin(self):
        """
        rbegin(TagVect self) -> std::vector< DFF::Tag * >::reverse_iterator

        1
        """
        return _libvfs.TagVect_rbegin(self)

    def rend(self):
        """
        rend(TagVect self) -> std::vector< DFF::Tag * >::reverse_iterator

        1
        """
        return _libvfs.TagVect_rend(self)

    def pop_back(self):
        """
        pop_back(TagVect self)

        1
        """
        return _libvfs.TagVect_pop_back(self)

    def erase(self, *args):
        """
        erase(TagVect self, std::vector< DFF::Tag * >::iterator pos) -> std::vector< DFF::Tag * >::iterator
        erase(TagVect self, std::vector< DFF::Tag * >::iterator first, std::vector< DFF::Tag * >::iterator last) -> std::vector< DFF::Tag * >::iterator

        1
        """
        return _libvfs.TagVect_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.DFF::Tag)> self) -> TagVect
        __init__(std::vector<(p.DFF::Tag)> self, TagVect arg2) -> TagVect
        __init__(std::vector<(p.DFF::Tag)> self, std::vector< DFF::Tag * >::size_type size) -> TagVect
        __init__(std::vector<(p.DFF::Tag)> self, std::vector< DFF::Tag * >::size_type size, Tag value) -> TagVect

        1
        """
        this = _libvfs.new_TagVect(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(TagVect self, Tag x)

        1
        """
        return _libvfs.TagVect_push_back(self, *args)

    def front(self):
        """
        front(TagVect self) -> Tag

        1
        """
        return _libvfs.TagVect_front(self)

    def back(self):
        """
        back(TagVect self) -> Tag

        1
        """
        return _libvfs.TagVect_back(self)

    def assign(self, *args):
        """
        assign(TagVect self, std::vector< DFF::Tag * >::size_type n, Tag x)

        1
        """
        return _libvfs.TagVect_assign(self, *args)

    def resize(self, *args):
        """
        resize(TagVect self, std::vector< DFF::Tag * >::size_type new_size)
        resize(TagVect self, std::vector< DFF::Tag * >::size_type new_size, Tag x)

        1
        """
        return _libvfs.TagVect_resize(self, *args)

    def insert(self, *args):
        """
        insert(TagVect self, std::vector< DFF::Tag * >::iterator pos, Tag x) -> std::vector< DFF::Tag * >::iterator
        insert(TagVect self, std::vector< DFF::Tag * >::iterator pos, std::vector< DFF::Tag * >::size_type n, 
            Tag x)

        1
        """
        return _libvfs.TagVect_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(TagVect self, std::vector< DFF::Tag * >::size_type n)

        1
        """
        return _libvfs.TagVect_reserve(self, *args)

    def capacity(self):
        """
        capacity(TagVect self) -> std::vector< DFF::Tag * >::size_type

        1
        """
        return _libvfs.TagVect_capacity(self)

    __swig_destroy__ = _libvfs.delete_TagVect
    __del__ = lambda self : None;
TagVect_swigregister = _libvfs.TagVect_swigregister
TagVect_swigregister(TagVect)

# This file is compatible with both classic and new-style classes.


