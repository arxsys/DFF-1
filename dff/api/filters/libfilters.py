# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libfilters', [dirname(__file__)])
        except ImportError:
            import _libfilters
            return _libfilters
        if fp is not None:
            try:
                _mod = imp.load_module('_libfilters', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libfilters = swig_import_helper()
    del swig_import_helper
else:
    import _libfilters
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libfilters.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _libfilters.SwigPyIterator_value(self)
    def incr(self, n=1): return _libfilters.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _libfilters.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _libfilters.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _libfilters.SwigPyIterator_equal(self, *args)
    def copy(self): return _libfilters.SwigPyIterator_copy(self)
    def next(self): return _libfilters.SwigPyIterator_next(self)
    def __next__(self): return _libfilters.SwigPyIterator___next__(self)
    def previous(self): return _libfilters.SwigPyIterator_previous(self)
    def advance(self, *args): return _libfilters.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _libfilters.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _libfilters.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _libfilters.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _libfilters.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _libfilters.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _libfilters.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _libfilters.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import dff.api.exceptions.libexceptions
import dff.api.vfs.libvfs
import dff.api.types.libtypes
import dff.api.events.libevents
class BadPatterns(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BadPatterns, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BadPatterns, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(BadPatterns self) -> SwigPyIterator

        1
        """
        return _libfilters.BadPatterns_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(BadPatterns self) -> bool

        1
        """
        return _libfilters.BadPatterns___nonzero__(self)

    def __bool__(self):
        """
        __bool__(BadPatterns self) -> bool

        1
        """
        return _libfilters.BadPatterns___bool__(self)

    def __len__(self):
        """
        __len__(BadPatterns self) -> std::vector< BadPattern * >::size_type

        1
        """
        return _libfilters.BadPatterns___len__(self)

    def pop(self):
        """
        pop(BadPatterns self) -> BadPattern

        1
        """
        return _libfilters.BadPatterns_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(BadPatterns self, std::vector< BadPattern * >::difference_type i, std::vector< BadPattern * >::difference_type j) -> BadPatterns

        1
        """
        return _libfilters.BadPatterns___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(BadPatterns self, std::vector< BadPattern * >::difference_type i, std::vector< BadPattern * >::difference_type j, 
            BadPatterns v=std::vector< BadPattern *,std::allocator< BadPattern * > >())
        __setslice__(BadPatterns self, std::vector< BadPattern * >::difference_type i, std::vector< BadPattern * >::difference_type j)

        1
        """
        return _libfilters.BadPatterns___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(BadPatterns self, std::vector< BadPattern * >::difference_type i, std::vector< BadPattern * >::difference_type j)

        1
        """
        return _libfilters.BadPatterns___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(BadPatterns self, std::vector< BadPattern * >::difference_type i)
        __delitem__(BadPatterns self, PySliceObject * slice)

        1
        """
        return _libfilters.BadPatterns___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(BadPatterns self, PySliceObject * slice) -> BadPatterns
        __getitem__(BadPatterns self, std::vector< BadPattern * >::difference_type i) -> BadPattern

        1
        """
        return _libfilters.BadPatterns___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(BadPatterns self, PySliceObject * slice, BadPatterns v)
        __setitem__(BadPatterns self, PySliceObject * slice)
        __setitem__(BadPatterns self, std::vector< BadPattern * >::difference_type i, BadPattern x)

        1
        """
        return _libfilters.BadPatterns___setitem__(self, *args)

    def append(self, *args):
        """
        append(BadPatterns self, BadPattern x)

        1
        """
        return _libfilters.BadPatterns_append(self, *args)

    def empty(self):
        """
        empty(BadPatterns self) -> bool

        1
        """
        return _libfilters.BadPatterns_empty(self)

    def size(self):
        """
        size(BadPatterns self) -> std::vector< BadPattern * >::size_type

        1
        """
        return _libfilters.BadPatterns_size(self)

    def clear(self):
        """
        clear(BadPatterns self)

        1
        """
        return _libfilters.BadPatterns_clear(self)

    def swap(self, *args):
        """
        swap(BadPatterns self, BadPatterns v)

        1
        """
        return _libfilters.BadPatterns_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(BadPatterns self) -> std::vector< BadPattern * >::allocator_type

        1
        """
        return _libfilters.BadPatterns_get_allocator(self)

    def begin(self):
        """
        begin(BadPatterns self) -> std::vector< BadPattern * >::iterator

        1
        """
        return _libfilters.BadPatterns_begin(self)

    def end(self):
        """
        end(BadPatterns self) -> std::vector< BadPattern * >::iterator

        1
        """
        return _libfilters.BadPatterns_end(self)

    def rbegin(self):
        """
        rbegin(BadPatterns self) -> std::vector< BadPattern * >::reverse_iterator

        1
        """
        return _libfilters.BadPatterns_rbegin(self)

    def rend(self):
        """
        rend(BadPatterns self) -> std::vector< BadPattern * >::reverse_iterator

        1
        """
        return _libfilters.BadPatterns_rend(self)

    def pop_back(self):
        """
        pop_back(BadPatterns self)

        1
        """
        return _libfilters.BadPatterns_pop_back(self)

    def erase(self, *args):
        """
        erase(BadPatterns self, std::vector< BadPattern * >::iterator pos) -> std::vector< BadPattern * >::iterator
        erase(BadPatterns self, std::vector< BadPattern * >::iterator first, std::vector< BadPattern * >::iterator last) -> std::vector< BadPattern * >::iterator

        1
        """
        return _libfilters.BadPatterns_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.BadPattern)> self) -> BadPatterns
        __init__(std::vector<(p.BadPattern)> self, BadPatterns arg2) -> BadPatterns
        __init__(std::vector<(p.BadPattern)> self, std::vector< BadPattern * >::size_type size) -> BadPatterns
        __init__(std::vector<(p.BadPattern)> self, std::vector< BadPattern * >::size_type size, BadPattern value) -> BadPatterns

        1
        """
        this = _libfilters.new_BadPatterns(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(BadPatterns self, BadPattern x)

        1
        """
        return _libfilters.BadPatterns_push_back(self, *args)

    def front(self):
        """
        front(BadPatterns self) -> BadPattern

        1
        """
        return _libfilters.BadPatterns_front(self)

    def back(self):
        """
        back(BadPatterns self) -> BadPattern

        1
        """
        return _libfilters.BadPatterns_back(self)

    def assign(self, *args):
        """
        assign(BadPatterns self, std::vector< BadPattern * >::size_type n, BadPattern x)

        1
        """
        return _libfilters.BadPatterns_assign(self, *args)

    def resize(self, *args):
        """
        resize(BadPatterns self, std::vector< BadPattern * >::size_type new_size)
        resize(BadPatterns self, std::vector< BadPattern * >::size_type new_size, BadPattern x)

        1
        """
        return _libfilters.BadPatterns_resize(self, *args)

    def insert(self, *args):
        """
        insert(BadPatterns self, std::vector< BadPattern * >::iterator pos, BadPattern x) -> std::vector< BadPattern * >::iterator
        insert(BadPatterns self, std::vector< BadPattern * >::iterator pos, std::vector< BadPattern * >::size_type n, 
            BadPattern x)

        1
        """
        return _libfilters.BadPatterns_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(BadPatterns self, std::vector< BadPattern * >::size_type n)

        1
        """
        return _libfilters.BadPatterns_reserve(self, *args)

    def capacity(self):
        """
        capacity(BadPatterns self) -> std::vector< BadPattern * >::size_type

        1
        """
        return _libfilters.BadPatterns_capacity(self)

    __swig_destroy__ = _libfilters.delete_BadPatterns
    __del__ = lambda self : None;
BadPatterns_swigregister = _libfilters.BadPatterns_swigregister
BadPatterns_swigregister(BadPatterns)

class VectString(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectString, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(VectString self) -> SwigPyIterator

        1
        """
        return _libfilters.VectString_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(VectString self) -> bool

        1
        """
        return _libfilters.VectString___nonzero__(self)

    def __bool__(self):
        """
        __bool__(VectString self) -> bool

        1
        """
        return _libfilters.VectString___bool__(self)

    def __len__(self):
        """
        __len__(VectString self) -> std::vector< std::string >::size_type

        1
        """
        return _libfilters.VectString___len__(self)

    def pop(self):
        """
        pop(VectString self) -> std::vector< std::string >::value_type

        1
        """
        return _libfilters.VectString_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(VectString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> VectString

        1
        """
        return _libfilters.VectString___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(VectString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            VectString v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(VectString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        1
        """
        return _libfilters.VectString___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(VectString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        1
        """
        return _libfilters.VectString___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(VectString self, std::vector< std::string >::difference_type i)
        __delitem__(VectString self, PySliceObject * slice)

        1
        """
        return _libfilters.VectString___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(VectString self, PySliceObject * slice) -> VectString
        __getitem__(VectString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &

        1
        """
        return _libfilters.VectString___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(VectString self, PySliceObject * slice, VectString v)
        __setitem__(VectString self, PySliceObject * slice)
        __setitem__(VectString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString___setitem__(self, *args)

    def append(self, *args):
        """
        append(VectString self, std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString_append(self, *args)

    def empty(self):
        """
        empty(VectString self) -> bool

        1
        """
        return _libfilters.VectString_empty(self)

    def size(self):
        """
        size(VectString self) -> std::vector< std::string >::size_type

        1
        """
        return _libfilters.VectString_size(self)

    def clear(self):
        """
        clear(VectString self)

        1
        """
        return _libfilters.VectString_clear(self)

    def swap(self, *args):
        """
        swap(VectString self, VectString v)

        1
        """
        return _libfilters.VectString_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(VectString self) -> std::vector< std::string >::allocator_type

        1
        """
        return _libfilters.VectString_get_allocator(self)

    def begin(self):
        """
        begin(VectString self) -> std::vector< std::string >::iterator

        1
        """
        return _libfilters.VectString_begin(self)

    def end(self):
        """
        end(VectString self) -> std::vector< std::string >::iterator

        1
        """
        return _libfilters.VectString_end(self)

    def rbegin(self):
        """
        rbegin(VectString self) -> std::vector< std::string >::reverse_iterator

        1
        """
        return _libfilters.VectString_rbegin(self)

    def rend(self):
        """
        rend(VectString self) -> std::vector< std::string >::reverse_iterator

        1
        """
        return _libfilters.VectString_rend(self)

    def pop_back(self):
        """
        pop_back(VectString self)

        1
        """
        return _libfilters.VectString_pop_back(self)

    def erase(self, *args):
        """
        erase(VectString self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(VectString self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator

        1
        """
        return _libfilters.VectString_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> VectString
        __init__(std::vector<(std::string)> self, VectString arg2) -> VectString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> VectString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> VectString

        1
        """
        this = _libfilters.new_VectString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(VectString self, std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString_push_back(self, *args)

    def front(self):
        """
        front(VectString self) -> std::vector< std::string >::value_type const &

        1
        """
        return _libfilters.VectString_front(self)

    def back(self):
        """
        back(VectString self) -> std::vector< std::string >::value_type const &

        1
        """
        return _libfilters.VectString_back(self)

    def assign(self, *args):
        """
        assign(VectString self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString_assign(self, *args)

    def resize(self, *args):
        """
        resize(VectString self, std::vector< std::string >::size_type new_size)
        resize(VectString self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString_resize(self, *args)

    def insert(self, *args):
        """
        insert(VectString self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(VectString self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)

        1
        """
        return _libfilters.VectString_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(VectString self, std::vector< std::string >::size_type n)

        1
        """
        return _libfilters.VectString_reserve(self, *args)

    def capacity(self):
        """
        capacity(VectString self) -> std::vector< std::string >::size_type

        1
        """
        return _libfilters.VectString_capacity(self)

    __swig_destroy__ = _libfilters.delete_VectString
    __del__ = lambda self : None;
VectString_swigregister = _libfilters.VectString_swigregister
VectString_swigregister(VectString)

class Dictionnaries(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionnaries, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionnaries, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(Dictionnaries self) -> SwigPyIterator

        1
        """
        return _libfilters.Dictionnaries_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(Dictionnaries self) -> bool

        1
        """
        return _libfilters.Dictionnaries___nonzero__(self)

    def __bool__(self):
        """
        __bool__(Dictionnaries self) -> bool

        1
        """
        return _libfilters.Dictionnaries___bool__(self)

    def __len__(self):
        """
        __len__(Dictionnaries self) -> std::map< std::string,Dictionnary * >::size_type

        1
        """
        return _libfilters.Dictionnaries___len__(self)

    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args):
        """
        __getitem__(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key) -> Dictionnary

        1
        """
        return _libfilters.Dictionnaries___getitem__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key)

        1
        """
        return _libfilters.Dictionnaries___delitem__(self, *args)

    def has_key(self, *args):
        """
        has_key(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key) -> bool

        1
        """
        return _libfilters.Dictionnaries_has_key(self, *args)

    def keys(self):
        """
        keys(Dictionnaries self) -> PyObject *

        1
        """
        return _libfilters.Dictionnaries_keys(self)

    def values(self):
        """
        values(Dictionnaries self) -> PyObject *

        1
        """
        return _libfilters.Dictionnaries_values(self)

    def items(self):
        """
        items(Dictionnaries self) -> PyObject *

        1
        """
        return _libfilters.Dictionnaries_items(self)

    def __contains__(self, *args):
        """
        __contains__(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key) -> bool

        1
        """
        return _libfilters.Dictionnaries___contains__(self, *args)

    def key_iterator(self):
        """
        key_iterator(Dictionnaries self) -> SwigPyIterator

        1
        """
        return _libfilters.Dictionnaries_key_iterator(self)

    def value_iterator(self):
        """
        value_iterator(Dictionnaries self) -> SwigPyIterator

        1
        """
        return _libfilters.Dictionnaries_value_iterator(self)

    def __setitem__(self, *args):
        """
        __setitem__(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key)
        __setitem__(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & key, Dictionnary x)

        1
        """
        return _libfilters.Dictionnaries___setitem__(self, *args)

    def asdict(self):
        """
        asdict(Dictionnaries self) -> PyObject *

        1
        """
        return _libfilters.Dictionnaries_asdict(self)

    def __init__(self, *args): 
        """
        __init__(std::map<(std::string,p.Dictionnary)> self, std::less< std::string > const & arg2) -> Dictionnaries
        __init__(std::map<(std::string,p.Dictionnary)> self) -> Dictionnaries
        __init__(std::map<(std::string,p.Dictionnary)> self, Dictionnaries arg2) -> Dictionnaries

        1
        """
        this = _libfilters.new_Dictionnaries(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self):
        """
        empty(Dictionnaries self) -> bool

        1
        """
        return _libfilters.Dictionnaries_empty(self)

    def size(self):
        """
        size(Dictionnaries self) -> std::map< std::string,Dictionnary * >::size_type

        1
        """
        return _libfilters.Dictionnaries_size(self)

    def clear(self):
        """
        clear(Dictionnaries self)

        1
        """
        return _libfilters.Dictionnaries_clear(self)

    def swap(self, *args):
        """
        swap(Dictionnaries self, Dictionnaries v)

        1
        """
        return _libfilters.Dictionnaries_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(Dictionnaries self) -> std::map< std::string,Dictionnary * >::allocator_type

        1
        """
        return _libfilters.Dictionnaries_get_allocator(self)

    def begin(self):
        """
        begin(Dictionnaries self) -> std::map< std::string,Dictionnary * >::iterator

        1
        """
        return _libfilters.Dictionnaries_begin(self)

    def end(self):
        """
        end(Dictionnaries self) -> std::map< std::string,Dictionnary * >::iterator

        1
        """
        return _libfilters.Dictionnaries_end(self)

    def rbegin(self):
        """
        rbegin(Dictionnaries self) -> std::map< std::string,Dictionnary * >::reverse_iterator

        1
        """
        return _libfilters.Dictionnaries_rbegin(self)

    def rend(self):
        """
        rend(Dictionnaries self) -> std::map< std::string,Dictionnary * >::reverse_iterator

        1
        """
        return _libfilters.Dictionnaries_rend(self)

    def count(self, *args):
        """
        count(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & x) -> std::map< std::string,Dictionnary * >::size_type

        1
        """
        return _libfilters.Dictionnaries_count(self, *args)

    def erase(self, *args):
        """
        erase(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & x) -> std::map< std::string,Dictionnary * >::size_type
        erase(Dictionnaries self, std::map< std::string,Dictionnary * >::iterator position)
        erase(Dictionnaries self, std::map< std::string,Dictionnary * >::iterator first, std::map< std::string,Dictionnary * >::iterator last)

        1
        """
        return _libfilters.Dictionnaries_erase(self, *args)

    def find(self, *args):
        """
        find(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & x) -> std::map< std::string,Dictionnary * >::iterator

        1
        """
        return _libfilters.Dictionnaries_find(self, *args)

    def lower_bound(self, *args):
        """
        lower_bound(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & x) -> std::map< std::string,Dictionnary * >::iterator

        1
        """
        return _libfilters.Dictionnaries_lower_bound(self, *args)

    def upper_bound(self, *args):
        """
        upper_bound(Dictionnaries self, std::map< std::string,Dictionnary * >::key_type const & x) -> std::map< std::string,Dictionnary * >::iterator

        1
        """
        return _libfilters.Dictionnaries_upper_bound(self, *args)

    __swig_destroy__ = _libfilters.delete_Dictionnaries
    __del__ = lambda self : None;
Dictionnaries_swigregister = _libfilters.Dictionnaries_swigregister
Dictionnaries_swigregister(Dictionnaries)

class VectTimeLineNode(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectTimeLineNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectTimeLineNode, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(VectTimeLineNode self) -> SwigPyIterator

        1
        """
        return _libfilters.VectTimeLineNode_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(VectTimeLineNode self) -> bool

        1
        """
        return _libfilters.VectTimeLineNode___nonzero__(self)

    def __bool__(self):
        """
        __bool__(VectTimeLineNode self) -> bool

        1
        """
        return _libfilters.VectTimeLineNode___bool__(self)

    def __len__(self):
        """
        __len__(VectTimeLineNode self) -> std::vector< TimeLineNode * >::size_type

        1
        """
        return _libfilters.VectTimeLineNode___len__(self)

    def pop(self):
        """
        pop(VectTimeLineNode self) -> TimeLineNode

        1
        """
        return _libfilters.VectTimeLineNode_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i, std::vector< TimeLineNode * >::difference_type j) -> std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > > *

        1
        """
        return _libfilters.VectTimeLineNode___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i, std::vector< TimeLineNode * >::difference_type j, 
            std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > > const & v=std::vector< TimeLineNode *,std::allocator< TimeLineNode * > >())
        __setslice__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i, std::vector< TimeLineNode * >::difference_type j)

        1
        """
        return _libfilters.VectTimeLineNode___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i, std::vector< TimeLineNode * >::difference_type j)

        1
        """
        return _libfilters.VectTimeLineNode___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i)
        __delitem__(VectTimeLineNode self, PySliceObject * slice)

        1
        """
        return _libfilters.VectTimeLineNode___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(VectTimeLineNode self, PySliceObject * slice) -> std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > >
        __getitem__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i) -> TimeLineNode

        1
        """
        return _libfilters.VectTimeLineNode___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(VectTimeLineNode self, PySliceObject * slice, std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > > const & v)
        __setitem__(VectTimeLineNode self, PySliceObject * slice)
        __setitem__(VectTimeLineNode self, std::vector< TimeLineNode * >::difference_type i, TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode___setitem__(self, *args)

    def append(self, *args):
        """
        append(VectTimeLineNode self, TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode_append(self, *args)

    def empty(self):
        """
        empty(VectTimeLineNode self) -> bool

        1
        """
        return _libfilters.VectTimeLineNode_empty(self)

    def size(self):
        """
        size(VectTimeLineNode self) -> std::vector< TimeLineNode * >::size_type

        1
        """
        return _libfilters.VectTimeLineNode_size(self)

    def clear(self):
        """
        clear(VectTimeLineNode self)

        1
        """
        return _libfilters.VectTimeLineNode_clear(self)

    def swap(self, *args):
        """
        swap(VectTimeLineNode self, VectTimeLineNode v)

        1
        """
        return _libfilters.VectTimeLineNode_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(VectTimeLineNode self) -> std::vector< TimeLineNode * >::allocator_type

        1
        """
        return _libfilters.VectTimeLineNode_get_allocator(self)

    def begin(self):
        """
        begin(VectTimeLineNode self) -> std::vector< TimeLineNode * >::iterator

        1
        """
        return _libfilters.VectTimeLineNode_begin(self)

    def end(self):
        """
        end(VectTimeLineNode self) -> std::vector< TimeLineNode * >::iterator

        1
        """
        return _libfilters.VectTimeLineNode_end(self)

    def rbegin(self):
        """
        rbegin(VectTimeLineNode self) -> std::vector< TimeLineNode * >::reverse_iterator

        1
        """
        return _libfilters.VectTimeLineNode_rbegin(self)

    def rend(self):
        """
        rend(VectTimeLineNode self) -> std::vector< TimeLineNode * >::reverse_iterator

        1
        """
        return _libfilters.VectTimeLineNode_rend(self)

    def pop_back(self):
        """
        pop_back(VectTimeLineNode self)

        1
        """
        return _libfilters.VectTimeLineNode_pop_back(self)

    def erase(self, *args):
        """
        erase(VectTimeLineNode self, std::vector< TimeLineNode * >::iterator pos) -> std::vector< TimeLineNode * >::iterator
        erase(VectTimeLineNode self, std::vector< TimeLineNode * >::iterator first, std::vector< TimeLineNode * >::iterator last) -> std::vector< TimeLineNode * >::iterator

        1
        """
        return _libfilters.VectTimeLineNode_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.TimeLineNode)> self) -> VectTimeLineNode
        __init__(std::vector<(p.TimeLineNode)> self, VectTimeLineNode arg2) -> VectTimeLineNode
        __init__(std::vector<(p.TimeLineNode)> self, std::vector< TimeLineNode * >::size_type size) -> VectTimeLineNode
        __init__(std::vector<(p.TimeLineNode)> self, std::vector< TimeLineNode * >::size_type size, TimeLineNode value) -> VectTimeLineNode

        1
        """
        this = _libfilters.new_VectTimeLineNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(VectTimeLineNode self, TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode_push_back(self, *args)

    def front(self):
        """
        front(VectTimeLineNode self) -> TimeLineNode

        1
        """
        return _libfilters.VectTimeLineNode_front(self)

    def back(self):
        """
        back(VectTimeLineNode self) -> TimeLineNode

        1
        """
        return _libfilters.VectTimeLineNode_back(self)

    def assign(self, *args):
        """
        assign(VectTimeLineNode self, std::vector< TimeLineNode * >::size_type n, TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode_assign(self, *args)

    def resize(self, *args):
        """
        resize(VectTimeLineNode self, std::vector< TimeLineNode * >::size_type new_size)
        resize(VectTimeLineNode self, std::vector< TimeLineNode * >::size_type new_size, TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode_resize(self, *args)

    def insert(self, *args):
        """
        insert(VectTimeLineNode self, std::vector< TimeLineNode * >::iterator pos, TimeLineNode x) -> std::vector< TimeLineNode * >::iterator
        insert(VectTimeLineNode self, std::vector< TimeLineNode * >::iterator pos, std::vector< TimeLineNode * >::size_type n, 
            TimeLineNode x)

        1
        """
        return _libfilters.VectTimeLineNode_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(VectTimeLineNode self, std::vector< TimeLineNode * >::size_type n)

        1
        """
        return _libfilters.VectTimeLineNode_reserve(self, *args)

    def capacity(self):
        """
        capacity(VectTimeLineNode self) -> std::vector< TimeLineNode * >::size_type

        1
        """
        return _libfilters.VectTimeLineNode_capacity(self)

    __swig_destroy__ = _libfilters.delete_VectTimeLineNode
    __del__ = lambda self : None;
VectTimeLineNode_swigregister = _libfilters.VectTimeLineNode_swigregister
VectTimeLineNode_swigregister(VectTimeLineNode)

class Filter(dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Filter, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Filter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::Filter self, std::string fname) -> Filter

        1
        """
        this = _libfilters.new_Filter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_Filter
    __del__ = lambda self : None;
    def query(self):
        """
        query(Filter self) -> std::string

        1
        """
        return _libfilters.Filter_query(self)

    def filterName(self):
        """
        filterName(Filter self) -> std::string

        1
        """
        return _libfilters.Filter_filterName(self)

    def Event(self, *args):
        """
        Event(Filter self, event e)

        1
        """
        return _libfilters.Filter_Event(self, *args)

    def setFilterName(self, *args):
        """
        setFilterName(Filter self, std::string fname)

        1
        """
        return _libfilters.Filter_setFilterName(self, *args)

    def compile(self, *args):
        """
        compile(Filter self, std::string query)

        1
        """
        return _libfilters.Filter_compile(self, *args)

    def processFolder(self, *args):
        """
        processFolder(Filter self, Node nodeptr)

        1
        """
        return _libfilters.Filter_processFolder(self, *args)

    def process(self, *args):
        """
        process(Filter self, Node nodeptr, bool recursive=True)
        process(Filter self, Node nodeptr)
        process(Filter self, ListNode nodes)
        process(Filter self, VecNode nodes)
        process(Filter self, uint64_t nodeid, bool recursive=True)
        process(Filter self, uint64_t nodeid)
        process(Filter self, fso fsobj)

        1
        """
        return _libfilters.Filter_process(self, *args)

    def match(self, *args):
        """
        match(Filter self, Node node) -> bool
        match(Filter self, uint64_t nodeId) -> bool

        1
        """
        return _libfilters.Filter_match(self, *args)

    def matchedNodes(self):
        """
        matchedNodes(Filter self) -> VecNode

        1
        """
        return _libfilters.Filter_matchedNodes(self)

    TotalNodesToProcess = _libfilters.Filter_TotalNodesToProcess
    ProcessedNodes = _libfilters.Filter_ProcessedNodes
    NodeMatched = _libfilters.Filter_NodeMatched
    StopProcessing = _libfilters.Filter_StopProcessing
    EndOfProcessing = _libfilters.Filter_EndOfProcessing
    AstReset = _libfilters.Filter_AstReset
Filter_swigregister = _libfilters.Filter_swigregister
Filter_swigregister(Filter)

class TimeLineNode(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeLineNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeLineNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(DFF::TimeLineNode self, Node node, std::string const & attributeName, DateTime time) -> TimeLineNode
        __init__(DFF::TimeLineNode self, TimeLineNode copy) -> TimeLineNode

        1
        """
        this = _libfilters.new_TimeLineNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_TimeLineNode
    __del__ = lambda self : None;
    def compare(*args):
        """
        compare(TimeLineNode a, TimeLineNode b) -> bool

        1
        """
        return _libfilters.TimeLineNode_compare(*args)

    if _newclass:compare = staticmethod(compare)
    __swig_getmethods__["compare"] = lambda x: compare
    def node(self):
        """
        node(TimeLineNode self) -> Node

        1
        """
        return _libfilters.TimeLineNode_node(self)

    def attribute(self):
        """
        attribute(TimeLineNode self) -> DateTime

        1
        """
        return _libfilters.TimeLineNode_attribute(self)

    def attributeName(self):
        """
        attributeName(TimeLineNode self) -> std::string const

        1
        """
        return _libfilters.TimeLineNode_attributeName(self)

TimeLineNode_swigregister = _libfilters.TimeLineNode_swigregister
TimeLineNode_swigregister(TimeLineNode)

def TimeLineNode_compare(*args):
  """
    TimeLineNode_compare(TimeLineNode a, TimeLineNode b) -> bool

    1
    """
  return _libfilters.TimeLineNode_compare(*args)

class TimeLine(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeLine, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """
        __init__(DFF::TimeLine self) -> TimeLine

        1
        """
        this = _libfilters.new_TimeLine()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_TimeLine
    __del__ = lambda self : None;
    def stop(self):
        """
        stop(TimeLine self)

        1
        """
        return _libfilters.TimeLine_stop(self)

    def sort(self, *args):
        """
        sort(TimeLine self, VecNode nodes) -> std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > > const &

        1
        """
        return _libfilters.TimeLine_sort(self, *args)

    def sorted(self):
        """
        sorted(TimeLine self) -> std::vector< DFF::TimeLineNode *,std::allocator< DFF::TimeLineNode * > > const &

        1
        """
        return _libfilters.TimeLine_sorted(self)

    def processed(self):
        """
        processed(TimeLine self) -> uint64_t

        1
        """
        return _libfilters.TimeLine_processed(self)

    def toProcess(self):
        """
        toProcess(TimeLine self) -> uint64_t

        1
        """
        return _libfilters.TimeLine_toProcess(self)

TimeLine_swigregister = _libfilters.TimeLine_swigregister
TimeLine_swigregister(TimeLine)

class QueryFlags(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QueryFlags, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QueryFlags, name)
    __repr__ = _swig_repr
    Empty = _libfilters.QueryFlags_Empty
    Primitive = _libfilters.QueryFlags_Primitive
    Tags = _libfilters.QueryFlags_Tags
    DataType = _libfilters.QueryFlags_DataType
    Advanced = _libfilters.QueryFlags_Advanced
    def __init__(self): 
        """
        __init__(QueryFlags self) -> QueryFlags

        1
        """
        this = _libfilters.new_QueryFlags()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_QueryFlags
    __del__ = lambda self : None;
QueryFlags_swigregister = _libfilters.QueryFlags_swigregister
QueryFlags_swigregister(QueryFlags)

class AttributeFactory(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributeFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributeFactory, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Named = _libfilters.AttributeFactory_Named
    Timestamp = _libfilters.AttributeFactory_Timestamp
    def instance():
        """
        instance() -> AttributeFactory

        1
        """
        return _libfilters.AttributeFactory_instance()

    if _newclass:instance = staticmethod(instance)
    __swig_getmethods__["instance"] = lambda x: instance
    def addKeyword(self, *args):
        """
        addKeyword(AttributeFactory self, std::string keyword, std::string fqn, AttributeFactory::CName type, QueryFlags::Level qflag) -> int

        1
        """
        return _libfilters.AttributeFactory_addKeyword(self, *args)

    def registerCreator(self, *args):
        """
        registerCreator(AttributeFactory self, AttributeFactory::CName type, AttributeFactory::CreateInstance creator) -> int

        1
        """
        return _libfilters.AttributeFactory_registerCreator(self, *args)

    def create(self, *args):
        """
        create(AttributeFactory self, std::string keyword) -> Expression *

        1
        """
        return _libfilters.AttributeFactory_create(self, *args)

    def getQueryFlags(self, *args):
        """
        getQueryFlags(AttributeFactory self, std::string fqn) -> QueryFlags::Level

        1
        """
        return _libfilters.AttributeFactory_getQueryFlags(self, *args)

AttributeFactory_swigregister = _libfilters.AttributeFactory_swigregister
AttributeFactory_swigregister(AttributeFactory)

def AttributeFactory_instance():
  """
    AttributeFactory_instance() -> AttributeFactory

    1
    """
  return _libfilters.AttributeFactory_instance()

class IndexedPatterns(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexedPatterns, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexedPatterns, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def instance():
        """
        instance() -> IndexedPatterns

        1
        """
        return _libfilters.IndexedPatterns_instance()

    if _newclass:instance = staticmethod(instance)
    __swig_getmethods__["instance"] = lambda x: instance
    def addPattern(self, *args):
        """
        addPattern(IndexedPatterns self, std::string arg2, Node node)

        1
        """
        return _libfilters.IndexedPatterns_addPattern(self, *args)

    def patternsByNode(self, *args):
        """
        patternsByNode(IndexedPatterns self, Node node) -> VectString

        1
        """
        return _libfilters.IndexedPatterns_patternsByNode(self, *args)

    def nodesByPattern(self, *args):
        """
        nodesByPattern(IndexedPatterns self, std::string pattern) -> VecNode

        1
        """
        return _libfilters.IndexedPatterns_nodesByPattern(self, *args)

IndexedPatterns_swigregister = _libfilters.IndexedPatterns_swigregister
IndexedPatterns_swigregister(IndexedPatterns)

def IndexedPatterns_instance():
  """
    IndexedPatterns_instance() -> IndexedPatterns

    1
    """
  return _libfilters.IndexedPatterns_instance()

class BadPattern(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BadPattern, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BadPattern, name)
    __repr__ = _swig_repr
    __swig_setmethods__["line"] = _libfilters.BadPattern_line_set
    __swig_getmethods__["line"] = _libfilters.BadPattern_line_get
    if _newclass:line = _swig_property(_libfilters.BadPattern_line_get, _libfilters.BadPattern_line_set)
    __swig_setmethods__["pattern"] = _libfilters.BadPattern_pattern_set
    __swig_getmethods__["pattern"] = _libfilters.BadPattern_pattern_get
    if _newclass:pattern = _swig_property(_libfilters.BadPattern_pattern_get, _libfilters.BadPattern_pattern_set)
    __swig_setmethods__["message"] = _libfilters.BadPattern_message_set
    __swig_getmethods__["message"] = _libfilters.BadPattern_message_get
    if _newclass:message = _swig_property(_libfilters.BadPattern_message_get, _libfilters.BadPattern_message_set)
    def __init__(self): 
        """
        __init__(BadPattern self) -> BadPattern

        1
        """
        this = _libfilters.new_BadPattern()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_BadPattern
    __del__ = lambda self : None;
BadPattern_swigregister = _libfilters.BadPattern_swigregister
BadPattern_swigregister(BadPattern)

class DictRegistry(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictRegistry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictRegistry, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def instance():
        """
        instance() -> DictRegistry

        1
        """
        return _libfilters.DictRegistry_instance()

    if _newclass:instance = staticmethod(instance)
    __swig_getmethods__["instance"] = lambda x: instance
    def add(self, *args):
        """
        add(DictRegistry self, std::string name, Dictionnary dict)

        1
        """
        return _libfilters.DictRegistry_add(self, *args)

    def remove(self, *args):
        """
        remove(DictRegistry self, std::string id)

        1
        """
        return _libfilters.DictRegistry_remove(self, *args)

    def get(self, *args):
        """
        get(DictRegistry self, std::string id) -> Dictionnary

        1
        """
        return _libfilters.DictRegistry_get(self, *args)

    def dictionnaries(self):
        """
        dictionnaries(DictRegistry self) -> Dictionnaries

        1
        """
        return _libfilters.DictRegistry_dictionnaries(self)

DictRegistry_swigregister = _libfilters.DictRegistry_swigregister
DictRegistry_swigregister(DictRegistry)

def DictRegistry_instance():
  """
    DictRegistry_instance() -> DictRegistry

    1
    """
  return _libfilters.DictRegistry_instance()

class Dictionnary(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dictionnary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dictionnary, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libfilters.delete_Dictionnary
    __del__ = lambda self : None;
    def badPatterns(self):
        """
        badPatterns(Dictionnary self) -> BadPatterns

        1
        """
        return _libfilters.Dictionnary_badPatterns(self)

    def nextSearchPattern(self):
        """
        nextSearchPattern(Dictionnary self) -> DFF::Search *

        1
        """
        return _libfilters.Dictionnary_nextSearchPattern(self)

    def reset(self):
        """
        reset(Dictionnary self)

        1
        """
        return _libfilters.Dictionnary_reset(self)

    def save(self, *args):
        """
        save(Dictionnary self, std::string path)

        1
        """
        return _libfilters.Dictionnary_save(self, *args)

    def fileName(self):
        """
        fileName(Dictionnary self) -> std::string

        1
        """
        return _libfilters.Dictionnary_fileName(self)

    def compile(self):
        """
        compile(Dictionnary self) -> bool

        1
        """
        return _libfilters.Dictionnary_compile(self)

Dictionnary_swigregister = _libfilters.Dictionnary_swigregister
Dictionnary_swigregister(Dictionnary)

class FileDictionnary(Dictionnary):
    """1"""
    __swig_setmethods__ = {}
    for _s in [Dictionnary]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileDictionnary, name, value)
    __swig_getmethods__ = {}
    for _s in [Dictionnary]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileDictionnary, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(FileDictionnary self, std::string ifile) -> FileDictionnary

        1
        """
        this = _libfilters.new_FileDictionnary(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _libfilters.delete_FileDictionnary
    __del__ = lambda self : None;
    def compile(self):
        """
        compile(FileDictionnary self) -> bool

        1
        """
        return _libfilters.FileDictionnary_compile(self)

    def save(self, *args):
        """
        save(FileDictionnary self, std::string path)

        1
        """
        return _libfilters.FileDictionnary_save(self, *args)

    def fileName(self):
        """
        fileName(FileDictionnary self) -> std::string

        1
        """
        return _libfilters.FileDictionnary_fileName(self)

FileDictionnary_swigregister = _libfilters.FileDictionnary_swigregister
FileDictionnary_swigregister(FileDictionnary)

# This file is compatible with both classic and new-style classes.


