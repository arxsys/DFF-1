# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CARVER', [dirname(__file__)])
        except ImportError:
            import _CARVER
            return _CARVER
        if fp is not None:
            try:
                _mod = imp.load_module('_CARVER', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _CARVER = swig_import_helper()
    del swig_import_helper
else:
    import _CARVER
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CARVER.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _CARVER.SwigPyIterator_value(self)
    def incr(self, n=1): return _CARVER.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _CARVER.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _CARVER.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _CARVER.SwigPyIterator_equal(self, *args)
    def copy(self): return _CARVER.SwigPyIterator_copy(self)
    def next(self): return _CARVER.SwigPyIterator_next(self)
    def __next__(self): return _CARVER.SwigPyIterator___next__(self)
    def previous(self): return _CARVER.SwigPyIterator_previous(self)
    def advance(self, *args): return _CARVER.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _CARVER.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _CARVER.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _CARVER.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _CARVER.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _CARVER.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _CARVER.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _CARVER.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import dff.api.vfs.libvfs
import dff.api.exceptions.libexceptions
import dff.api.types.libtypes
import dff.api.events.libevents
class CarvedNode(dff.api.vfs.libvfs.Node):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.vfs.libvfs.Node]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CarvedNode, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.vfs.libvfs.Node]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CarvedNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(CarvedNode self, std::string name, uint64_t size, Node parent, fso fsobj) -> CarvedNode

        1
        """
        this = _CARVER.new_CarvedNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _CARVER.delete_CarvedNode
    __del__ = lambda self : None;
    def setStart(self, *args):
        """
        setStart(CarvedNode self, uint64_t start)

        1
        """
        return _CARVER.CarvedNode_setStart(self, *args)

    def setOrigin(self, *args):
        """
        setOrigin(CarvedNode self, Node origin)

        1
        """
        return _CARVER.CarvedNode_setOrigin(self, *args)

    def fileMapping(self, *args):
        """
        fileMapping(CarvedNode self, FileMapping fm)

        The fileMapping method takes a pointer to an instance of a FileMapping object
        as parameter. This method is called when a node is opened.

        The fileMapping method must "filled up" the FileMapping object which was passed
        to it by creating chunks of the files. A chunk is a structure containing 2
        important informations :
         * The size (in bytes) of the chunk
         * Its address on the vfile.

        In human speakable langugage it means that the FileMapping structure contains
        a list of data structure, each of them giving a part of the file content position
        on the vfile.

        FileMapping can be filled up by calling their push() method.

        """
        return _CARVER.CarvedNode_fileMapping(self, *args)

CarvedNode_swigregister = _CARVER.CarvedNode_swigregister
CarvedNode_swigregister(CarvedNode)

class Carver(dff.api.vfs.libvfs.mfso,dff.api.events.libevents.EventHandler):
    """1"""
    __swig_setmethods__ = {}
    for _s in [dff.api.vfs.libvfs.mfso,dff.api.events.libevents.EventHandler]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Carver, name, value)
    __swig_getmethods__ = {}
    for _s in [dff.api.vfs.libvfs.mfso,dff.api.events.libevents.EventHandler]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Carver, name)
    __repr__ = _swig_repr
    Position = _CARVER.Carver_Position
    Matches = _CARVER.Carver_Matches
    EndOfProcessing = _CARVER.Carver_EndOfProcessing
    Stop = _CARVER.Carver_Stop
    def __init__(self): 
        """
        __init__(Carver self) -> Carver

        1
        """
        this = _CARVER.new_Carver()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _CARVER.delete_Carver
    __del__ = lambda self : None;
    def tell(self):
        """
        tell(Carver self) -> uint64_t

        1
        """
        return _CARVER.Carver_tell(self)

    def start(self, *args):
        """
        start(Carver self, VMap args)

        start(self, argument args)

        This method is pure virtual in mfso so musts be implemented while developing
        a module.

        This method is called when the module starts. It does the job the module
        is supposed to do. This method is declared as a pure virtual so each modules
        must reiplements it (see the developer's documentations for more details) in
        python or C++, depending on which language you choose.

        The parameter 'args' is pointer to the arguments list which were passed to the
        module when it was launched. You can get them by using the method

          args->get("arg_name", &variable)

        where variable must be of the same type than the argument "arg_name"

        If you create nodes, you must not forget to call the method register_tree at
        the end of the module execution.

        If an error occured while getting a parameter, a envError exception is thrown.

        Params :
                * args : the list of arguments.


        """
        return _CARVER.Carver_start(self, *args)

    def Event(self, *args):
        """
        Event(Carver self, event e)

        1
        """
        return _CARVER.Carver_Event(self, *args)

    def Read(self, *args):
        """
        Read(Carver self, char * buffer, unsigned int size) -> int

        1
        """
        return _CARVER.Carver_Read(self, *args)

Carver_swigregister = _CARVER.Carver_swigregister
Carver_swigregister(Carver)

class listDescr(_object):
    """1"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, listDescr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, listDescr, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(listDescr self) -> SwigPyIterator

        1
        """
        return _CARVER.listDescr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(listDescr self) -> bool

        1
        """
        return _CARVER.listDescr___nonzero__(self)

    def __bool__(self):
        """
        __bool__(listDescr self) -> bool

        1
        """
        return _CARVER.listDescr___bool__(self)

    def __len__(self):
        """
        __len__(listDescr self) -> std::list< description * >::size_type

        1
        """
        return _CARVER.listDescr___len__(self)

    def pop(self):
        """
        pop(listDescr self) -> std::list< description * >::value_type

        1
        """
        return _CARVER.listDescr_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(listDescr self, std::list< description * >::difference_type i, std::list< description * >::difference_type j) -> listDescr

        1
        """
        return _CARVER.listDescr___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(listDescr self, std::list< description * >::difference_type i, std::list< description * >::difference_type j, 
            listDescr v=std::list< description *,std::allocator< description * > >())
        __setslice__(listDescr self, std::list< description * >::difference_type i, std::list< description * >::difference_type j)

        1
        """
        return _CARVER.listDescr___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(listDescr self, std::list< description * >::difference_type i, std::list< description * >::difference_type j)

        1
        """
        return _CARVER.listDescr___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(listDescr self, std::list< description * >::difference_type i)
        __delitem__(listDescr self, PySliceObject * slice)

        1
        """
        return _CARVER.listDescr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(listDescr self, PySliceObject * slice) -> listDescr
        __getitem__(listDescr self, std::list< description * >::difference_type i) -> std::list< description * >::value_type

        1
        """
        return _CARVER.listDescr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(listDescr self, PySliceObject * slice, listDescr v)
        __setitem__(listDescr self, PySliceObject * slice)
        __setitem__(listDescr self, std::list< description * >::difference_type i, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr___setitem__(self, *args)

    def append(self, *args):
        """
        append(listDescr self, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_append(self, *args)

    def empty(self):
        """
        empty(listDescr self) -> bool

        1
        """
        return _CARVER.listDescr_empty(self)

    def size(self):
        """
        size(listDescr self) -> std::list< description * >::size_type

        1
        """
        return _CARVER.listDescr_size(self)

    def clear(self):
        """
        clear(listDescr self)

        1
        """
        return _CARVER.listDescr_clear(self)

    def swap(self, *args):
        """
        swap(listDescr self, listDescr v)

        1
        """
        return _CARVER.listDescr_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(listDescr self) -> std::list< description * >::allocator_type

        1
        """
        return _CARVER.listDescr_get_allocator(self)

    def begin(self):
        """
        begin(listDescr self) -> std::list< description * >::iterator

        1
        """
        return _CARVER.listDescr_begin(self)

    def end(self):
        """
        end(listDescr self) -> std::list< description * >::iterator

        1
        """
        return _CARVER.listDescr_end(self)

    def rbegin(self):
        """
        rbegin(listDescr self) -> std::list< description * >::reverse_iterator

        1
        """
        return _CARVER.listDescr_rbegin(self)

    def rend(self):
        """
        rend(listDescr self) -> std::list< description * >::reverse_iterator

        1
        """
        return _CARVER.listDescr_rend(self)

    def pop_back(self):
        """
        pop_back(listDescr self)

        1
        """
        return _CARVER.listDescr_pop_back(self)

    def erase(self, *args):
        """
        erase(listDescr self, std::list< description * >::iterator pos) -> std::list< description * >::iterator
        erase(listDescr self, std::list< description * >::iterator first, std::list< description * >::iterator last) -> std::list< description * >::iterator

        1
        """
        return _CARVER.listDescr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::list<(p.description)> self) -> listDescr
        __init__(std::list<(p.description)> self, listDescr arg2) -> listDescr
        __init__(std::list<(p.description)> self, std::list< description * >::size_type size) -> listDescr
        __init__(std::list<(p.description)> self, std::list< description * >::size_type size, std::list< description * >::value_type value) -> listDescr

        1
        """
        this = _CARVER.new_listDescr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(listDescr self, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_push_back(self, *args)

    def front(self):
        """
        front(listDescr self) -> std::list< description * >::value_type

        1
        """
        return _CARVER.listDescr_front(self)

    def back(self):
        """
        back(listDescr self) -> std::list< description * >::value_type

        1
        """
        return _CARVER.listDescr_back(self)

    def assign(self, *args):
        """
        assign(listDescr self, std::list< description * >::size_type n, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_assign(self, *args)

    def resize(self, *args):
        """
        resize(listDescr self, std::list< description * >::size_type new_size)
        resize(listDescr self, std::list< description * >::size_type new_size, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_resize(self, *args)

    def insert(self, *args):
        """
        insert(listDescr self, std::list< description * >::iterator pos, std::list< description * >::value_type x) -> std::list< description * >::iterator
        insert(listDescr self, std::list< description * >::iterator pos, std::list< description * >::size_type n, 
            std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_insert(self, *args)

    def pop_front(self):
        """
        pop_front(listDescr self)

        1
        """
        return _CARVER.listDescr_pop_front(self)

    def push_front(self, *args):
        """
        push_front(listDescr self, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_push_front(self, *args)

    def remove(self, *args):
        """
        remove(listDescr self, std::list< description * >::value_type x)

        1
        """
        return _CARVER.listDescr_remove(self, *args)

    def unique(self):
        """
        unique(listDescr self)

        1
        """
        return _CARVER.listDescr_unique(self)

    def reverse(self):
        """
        reverse(listDescr self)

        1
        """
        return _CARVER.listDescr_reverse(self)

    def sort(self):
        """
        sort(listDescr self)

        1
        """
        return _CARVER.listDescr_sort(self)

    def merge(self, *args):
        """
        merge(listDescr self, listDescr x)

        1
        """
        return _CARVER.listDescr_merge(self, *args)

    __swig_destroy__ = _CARVER.delete_listDescr
    __del__ = lambda self : None;
listDescr_swigregister = _CARVER.listDescr_swigregister
listDescr_swigregister(listDescr)

__dff_module_carver_version__ = "1.0.0"

from dff.api.module.module import Module
from dff.api.types.libtypes import Argument, typeId, Variant

class CARVER(Module):
    """Search for header and footer of a selected mime-type in a node and create the corresponding file.
    You can use this modules for finding deleted data or data in slack space or in an unknown file system."""
    def __init__(self):
        Module.__init__(self, 'carver', Carver)

        self.conf.addArgument({"name": "file",
                               "description": "file used by carver",
                               "input": Argument.Required|Argument.Single|typeId.Node})
        needle = Argument("needle", Argument.Required|Argument.Single|typeId.String, "represents the needle to search in the haystack")
        needle.thisown = False

        wildcard = Argument("wildcard", Argument.Required|Argument.Single|typeId.Char, "represents wildcard character used to match anything")
        wildcard.thisown = False

        size = Argument("size", Argument.Required|Argument.Single|typeId.UInt32, "size of the needle. Needed in order to take into account \0")
        size.thisown = False

        header = Argument("header", Argument.Required|Argument.Single|typeId.Argument, "represents the header, generally corresponding to the starting magic value")
        header.addSubArgument(needle)
        header.addSubArgument(wildcard)
        header.addSubArgument(size)
        header.thisown = False

        needle = Argument("needle", Argument.Required|Argument.Single|typeId.String, "represents the needle to search in the haystack")
        needle.thisown = False

        wildcard = Argument("wildcard", Argument.Required|Argument.Single|typeId.Char, "represents wildcard character used to match anything")
        wildcard.thisown = False

        size = Argument("size", Argument.Required|Argument.Single|typeId.UInt32, "size of the needle. Needed in order to take into account \0")
        size.thisown = False

        footer = Argument("footer", Argument.Optional|Argument.Single|typeId.Argument, "represents the footer, generally corresponding to the ending magic value")
        footer.addSubArgument(needle)
        footer.addSubArgument(wildcard)
        footer.addSubArgument(size)
        footer.thisown = False

        filetype = Argument("filetype", Argument.Required|Argument.Single|typeId.String, "name of the filetype corresponding to the current pattern automaton")
        filetype.thisown = False

        window = Argument("window", Argument.Required|Argument.Single|typeId.UInt32, "maximum size to associate when no footers found or not defined")
        window.thisown = False

        aligned = Argument("aligned", Argument.Empty, "defines if headers have to be aligned to sectors")
        aligned.thisown = False

        base64 = Argument("b64", Argument.Empty, "defines if matching base64 encoded files")
        base64.thisown = False

        blksize = Argument("blksize", Argument.Optional|Argument.Single|typeId.UInt32)
        blksize.thisown = False

        pattern = Argument("pattern", Argument.Required|Argument.Single|typeId.Argument, "defines a matching context for carving files. Associate a header and a footer")
        pattern.addSubArgument(filetype)
        pattern.addSubArgument(header)
        pattern.addSubArgument(footer)
        pattern.addSubArgument(window)
        pattern.addSubArgument(aligned)
        pattern.addSubArgument(base64)
        pattern.addSubArgument(blksize)
        pattern.thisown = False

        patterns = Argument("patterns", Argument.Required|Argument.List|typeId.Argument, "defines a matching context for carving files")
        patterns.thisown = False
        patterns.addSubArgument(pattern)

        self.conf.addArgument(patterns)
        self.conf.addArgument({"name": "start-offset",
                               "input": Argument.Single|Argument.Optional|typeId.UInt64,
                               "description": "offset where to start carving"})
        self.tags = "builtins"

# This file is compatible with both classic and new-style classes.


